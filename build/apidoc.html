<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://abal.moe/Eris/"

    >eris (v0.6.0)</a>
</h1>
<h4>A NodeJS Discord library</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.eris">module eris</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.eris">
            function <span class="apidocSignatureSpan"></span>eris
            <span class="apidocSignatureSpan">(token, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Bucket">
            function <span class="apidocSignatureSpan">eris.</span>Bucket
            <span class="apidocSignatureSpan">(in ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Call">
            function <span class="apidocSignatureSpan">eris.</span>Call
            <span class="apidocSignatureSpan">(data, channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Channel">
            function <span class="apidocSignatureSpan">eris.</span>Channel
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Client">
            function <span class="apidocSignatureSpan">eris.</span>Client
            <span class="apidocSignatureSpan">(all options are optional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Collection">
            function <span class="apidocSignatureSpan">eris.</span>Collection
            <span class="apidocSignatureSpan">(baseObject, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Command">
            function <span class="apidocSignatureSpan">eris.</span>Command
            <span class="apidocSignatureSpan">(msg, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.CommandClient">
            function <span class="apidocSignatureSpan">eris.</span>CommandClient
            <span class="apidocSignatureSpan">(same as Client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.ExtendedUser">
            function <span class="apidocSignatureSpan">eris.</span>ExtendedUser
            <span class="apidocSignatureSpan">(data, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.FFmpegDuplex">
            function <span class="apidocSignatureSpan">eris.</span>FFmpegDuplex
            <span class="apidocSignatureSpan">(command, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.GroupChannel">
            function <span class="apidocSignatureSpan">eris.</span>GroupChannel
            <span class="apidocSignatureSpan">(╯°□°）╯︵ ┻━┻ constructor(data, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Guild">
            function <span class="apidocSignatureSpan">eris.</span>Guild
            <span class="apidocSignatureSpan">(data, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.GuildChannel">
            function <span class="apidocSignatureSpan">eris.</span>GuildChannel
            <span class="apidocSignatureSpan">(data, guild, messageLimit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.GuildIntegration">
            function <span class="apidocSignatureSpan">eris.</span>GuildIntegration
            <span class="apidocSignatureSpan">(data, guild)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Invite">
            function <span class="apidocSignatureSpan">eris.</span>Invite
            <span class="apidocSignatureSpan">(data, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Member">
            function <span class="apidocSignatureSpan">eris.</span>Member
            <span class="apidocSignatureSpan">(data, guild)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Message">
            function <span class="apidocSignatureSpan">eris.</span>Message
            <span class="apidocSignatureSpan">(data, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Permission">
            function <span class="apidocSignatureSpan">eris.</span>Permission
            <span class="apidocSignatureSpan">(allow, deny)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.PermissionOverwrite">
            function <span class="apidocSignatureSpan">eris.</span>PermissionOverwrite
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.PrivateChannel">
            function <span class="apidocSignatureSpan">eris.</span>PrivateChannel
            <span class="apidocSignatureSpan">(data, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Relationship">
            function <span class="apidocSignatureSpan">eris.</span>Relationship
            <span class="apidocSignatureSpan">(data, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Role">
            function <span class="apidocSignatureSpan">eris.</span>Role
            <span class="apidocSignatureSpan">(data, guild)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Shard">
            function <span class="apidocSignatureSpan">eris.</span>Shard
            <span class="apidocSignatureSpan">(id, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.SharedStream">
            function <span class="apidocSignatureSpan">eris.</span>SharedStream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.User">
            function <span class="apidocSignatureSpan">eris.</span>User
            <span class="apidocSignatureSpan">(data, client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.VoiceConnection">
            function <span class="apidocSignatureSpan">eris.</span>VoiceConnection
            <span class="apidocSignatureSpan">(id, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.VoiceConnectionManager">
            function <span class="apidocSignatureSpan">eris.</span>VoiceConnectionManager
            <span class="apidocSignatureSpan">(vcObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.VoiceState">
            function <span class="apidocSignatureSpan">eris.</span>VoiceState
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eris.</span>Constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eris.</span>Endpoints</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eris.</span>FFmpegDuplex.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eris.Endpoints">module eris.Endpoints</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_BULK_DELETE">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_BULK_DELETE
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_CALL_RING">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_CALL_RING
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_INVITES">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_INVITES
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGE">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGE
            <span class="apidocSignatureSpan">(chanID, msgID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGES">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGES
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGES_SEARCH">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGES_SEARCH
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGE_REACTION">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGE_REACTION
            <span class="apidocSignatureSpan">(chanID, msgID, reaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGE_REACTIONS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGE_REACTIONS
            <span class="apidocSignatureSpan">(chanID, msgID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGE_REACTION_USER">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGE_REACTION_USER
            <span class="apidocSignatureSpan">(chanID, msgID, reaction, userID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_PERMISSION">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_PERMISSION
            <span class="apidocSignatureSpan">(chanID, overID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_PERMISSIONS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_PERMISSIONS
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_PIN">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_PIN
            <span class="apidocSignatureSpan">(chanID, msgID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_PINS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_PINS
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_RECIPIENT">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_RECIPIENT
            <span class="apidocSignatureSpan">(groupID, userID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_TYPING">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_TYPING
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.CHANNEL_WEBHOOKS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_WEBHOOKS
            <span class="apidocSignatureSpan">(chanID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_BAN">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_BAN
            <span class="apidocSignatureSpan">(guildID, memberID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_BANS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_BANS
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_CHANNELS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_CHANNELS
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_EMBED">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_EMBED
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_EMOJI">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_EMOJI
            <span class="apidocSignatureSpan">(guildID, emojiID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_EMOJIS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_EMOJIS
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_INTEGRATION">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_INTEGRATION
            <span class="apidocSignatureSpan">(guildID, inteID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_INTEGRATIONS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_INTEGRATIONS
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_INTEGRATION_SYNC">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_INTEGRATION_SYNC
            <span class="apidocSignatureSpan">(guildID, inteID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_INVITES">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_INVITES
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_MEMBER">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MEMBER
            <span class="apidocSignatureSpan">(guildID, memberID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_MEMBERS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MEMBERS
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_MEMBER_NICK">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MEMBER_NICK
            <span class="apidocSignatureSpan">(guildID, memberID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_MEMBER_ROLE">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MEMBER_ROLE
            <span class="apidocSignatureSpan">(guildID, memberID, roleID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_MESSAGES_SEARCH">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MESSAGES_SEARCH
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_PRUNE">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_PRUNE
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_ROLE">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_ROLE
            <span class="apidocSignatureSpan">(guildID, roleID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_ROLES">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_ROLES
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_VOICE_REGIONS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_VOICE_REGIONS
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.GUILD_WEBHOOKS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_WEBHOOKS
            <span class="apidocSignatureSpan">(guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.INVITE">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>INVITE
            <span class="apidocSignatureSpan">(inviteID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.OAUTH2_APPLICATION">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>OAUTH2_APPLICATION
            <span class="apidocSignatureSpan">(appID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.USER">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER
            <span class="apidocSignatureSpan">(userID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.USER_CHANNELS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_CHANNELS
            <span class="apidocSignatureSpan">(userID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.USER_GUILD">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_GUILD
            <span class="apidocSignatureSpan">(userID, guildID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.USER_GUILDS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_GUILDS
            <span class="apidocSignatureSpan">(userID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.USER_NOTE">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_NOTE
            <span class="apidocSignatureSpan">(userID, targetID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.USER_PROFILE">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_PROFILE
            <span class="apidocSignatureSpan">(userID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.USER_RELATIONSHIP">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_RELATIONSHIP
            <span class="apidocSignatureSpan">(userID, relID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.USER_SETTINGS">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_SETTINGS
            <span class="apidocSignatureSpan">(userID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.WEBHOOK">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>WEBHOOK
            <span class="apidocSignatureSpan">(hookID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.WEBHOOK_TOKEN">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>WEBHOOK_TOKEN
            <span class="apidocSignatureSpan">(hookID, token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.Endpoints.WEBHOOK_TOKEN_SLACK">
            function <span class="apidocSignatureSpan">eris.Endpoints.</span>WEBHOOK_TOKEN_SLACK
            <span class="apidocSignatureSpan">(hookID, token)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eris.Endpoints.</span>BASE_URL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eris.Endpoints.</span>CDN_URL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNELS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eris.Endpoints.</span>GATEWAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eris.Endpoints.</span>GATEWAY_BOT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILDS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eris.Endpoints.</span>USERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eris.Endpoints.</span>VOICE_REGIONS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eris.FFmpegDuplex">module eris.FFmpegDuplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.FFmpegDuplex.FFmpegDuplex">
            function <span class="apidocSignatureSpan">eris.</span>FFmpegDuplex
            <span class="apidocSignatureSpan">(command, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.FFmpegDuplex.spawn">
            function <span class="apidocSignatureSpan">eris.FFmpegDuplex.</span>spawn
            <span class="apidocSignatureSpan">(connection, args, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eris.FFmpegDuplex.prototype">module eris.FFmpegDuplex.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eris.FFmpegDuplex.prototype.addListener">
            function <span class="apidocSignatureSpan">eris.FFmpegDuplex.prototype.</span>addListener
            <span class="apidocSignatureSpan">(ev, fn)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eris" id="apidoc.module.eris">module eris</a></h1>


    <h2>
        <a href="#apidoc.element.eris.eris" id="apidoc.element.eris.eris">
        function <span class="apidocSignatureSpan"></span>eris
        <span class="apidocSignatureSpan">(token, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Eris(token, options) {
    return new Client(token, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Bucket" id="apidoc.element.eris.Bucket">
        function <span class="apidocSignatureSpan">eris.</span>Bucket
        <span class="apidocSignatureSpan">(in ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Bucket {
<span class="apidocCodeCommentSpan">    /**
    * Construct a Bucket
    * @arg {Number} tokenLimit The max number of tokens the bucket can consume per interval
    * @arg {Number} interval How long (in ms) to wait between clearing used tokens
    * @arg {Object} [latencyRef] An object
    * @arg {Number} latencyRef.latency Interval between consuming tokens
    */
</span>    constructor(tokenLimit, interval, latencyRef) {
        this.tokenLimit = tokenLimit;
        this.interval = interval;
        this.latencyRef = latencyRef || {
            latency: 0
        };
        this.lastReset = this.tokens = this.lastSend = 0;
        this._queue = [];
    }

    /**
    * Queue something in the Bucket
    * @arg {Function} func A callback to call when a token can be consumed
    */
    queue(func) {
        this._queue.push(func);
        this.check();
    }

    check() {
        if(this.timeout || this._queue.length === 0) {
            return;
        }
        if(this.lastReset + this.interval + this.tokenLimit * this.latencyRef.latency &#x3c; Date.now()) {
            this.lastReset = Date.now();
            this.tokens = Math.max(0, this.tokens - this.tokenLimit);
        }

        var val;
        while(this._queue.length &#x3e; 0 &#x26;&#x26; this.tokens &#x3c; this.tokenLimit) {
            this.tokens++;
            let item = this._queue.shift();
            val = this.latencyRef.latency - Date.now() + this.lastSend;
            if(this.latencyRef.latency === 0 || val &#x3c;= 0) {
                item();
                this.lastSend = Date.now();
            } else {
                setTimeout(() =&#x3e; {
                    item();
                }, val);
                this.lastSend = Date.now() + val;
            }
        }

        if(this._queue.length &#x3e; 0 &#x26;&#x26; !this.timeout) {
            this.timeout = setTimeout(() =&#x3e; {
                this.timeout = null;
                this.check();
            }, this.tokens &#x3c; this.tokenLimit ? this.latencyRef.latency : Math.max(0, this.lastReset + this.interval + this.tokenLimit
 * this.latencyRef.latency - Date.now()));
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Call" id="apidoc.element.eris.Call">
        function <span class="apidocSignatureSpan">eris.</span>Call
        <span class="apidocSignatureSpan">(data, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Call extends Base {
    constructor(data, channel) {
        super(data.id);
        this.channel = channel;
        this.voiceStates = new Collection(VoiceState);
        this.ringing = [];
        this.update(data);
    }

    update(data) {
        this.participants = data.participants !== undefined ? data.participants : this.participants || [];
        if(data.ringing !== undefined) {
            if(!~this.ringing.indexOf(this.channel._client.user.id) &#x26;&#x26; ~(this.ringing = data.ringing).indexOf(this.channel._client
.user.id)) {
<span class="apidocCodeCommentSpan">                /**
                * Fired when the bot user is rung in a call
                * @event Client#callRing
                * @prop {Call} call The call
                */
</span>                this.channel._client.emit(&#x22;callRing&#x22;, this);
            }
        }
        this.region = data.region !== undefined ? data.region : this.region || null;
        this.endedTimestamp = data.ended_timestamp !== undefined ? Date.parse(data.ended_timestamp) : this.endedTimestamp || null
;
        this.unavailable = data.unavailable !== undefined ? data.unavailable : this.unavailable !== undefined ? this.unavailable
 : true;
        if(data.voice_states) {
            data.voice_states.forEach((voiceState) =&#x3e; {
                voiceState.id = voiceState.user_id;
                this.voiceStates.add(voiceState);
            });
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Channel" id="apidoc.element.eris.Channel">
        function <span class="apidocSignatureSpan">eris.</span>Channel
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Channel extends Base {
    constructor(data) {
        super(data.id);
        this.type = data.type;
    }

<span class="apidocCodeCommentSpan">    /**
    * Send typing status in a text channel
    * @returns {Promise}
    */
</span>    sendTyping() {
        return (this._client || this.guild.shard.client).sendChannelTyping.call((this._client || this.guild.shard.client), this.
id);
    }

    /**
    * Get a previous message in a text channel
    * @arg {String} messageID The ID of the message
    * @returns {Promise&#x3c;Message&#x3e;}
    */
    getMessage(messageID) {
        return (this._client || this.guild.shard.client).getMessage.call((this._client || this.guild.shard.client), this.id, messageID
);
    }

    /**
    * Get a previous message in a text channel
    * @arg {Number} [limit=50] The max number of messages to get
    * @arg {String} [before] Get messages before this message ID
    * @arg {String} [after] Get messages after this message ID
    * @arg {String} [around] Get messages around this message ID (does not work with limit &#x3e; 100)
    * @returns {Promise&#x3c;Message[]&#x3e;}
    */
    getMessages(limit, before, after, around) {
        return (this._client || this.guild.shard.client).getMessages.call((this._client || this.guild.shard.client), this.id, limit
, before, after, around);
    }

    /**
    * Get all the pins in a text channel
    * @returns {Promise&#x3c;Message[]&#x3e;}
    */
    getPins() {
        return (this._client || this.guild.shard.client).getPins.call((this._client || this.guild.shard.client), this.id);
    }

    /**
    * Create a message in a text channel
    * Note: If you want to DM someone, the user ID is **not** the DM channel ID. use Client.getDMChanne() to get the DM channel
ID for a user
    * @arg {String | Object} content A string or object. If an object is passed:
    * @arg {String} content.content A content string
    * @arg {Boolean} [content.tts] Set the message TTS flag
    * @arg {Boolean} [content.disableEveryone] Whether to filter @everyone/@here or not (overrides default)
    * @arg {Object} [content.embed] An embed object. See [the official Discord API documentation entry](https://discordapp.com/developers
/docs/resources/channel#embed-object) for object structure
    * @arg {Object} [file] A file object
    * @arg {String} file.file A buffer containing file data
    * @arg {String} file.name What to name the file
    * @returns {Promise&#x3c;Message&#x3e;}
    */
    createMessage(content, file) {
        return (this._client || this.guild.shard.client).createMessage.call((this._client || this.guild.shard.client), this.id,
content, file);
    }

    /**
    * Edit a message
    * @arg {String} messageID The ID of the message
    * @arg {String | Array | Object} content A string, array of strings, or object. If an object is passed:
    * @arg {String} content.content A content string
    * @arg {Boolean} [content.disableEveryone] Whether to filter @everyone/@here or not (overrides default)
    * @arg {Object} [content.embed] An embed object. See [the official Discord API documentation entry](https://discordapp.com/developers
/docs/resources/channel#embed-object) for object structure
    * @returns {Promise&#x3c;Message&#x3e;}
    */
    editMessage(messageID, content) {
        return (this._client || this.guild.shard.client).editMessage.call((this._client || this.guild.shard.client), this.id, messageID
, content);
    }

    /**
    * Pin a message
    * @arg {String} messageID The ID of the message
    * @returns {Promise}
    */
    pinMessage(messageID) {
        return (this._client || this.guild.shard.client).pinMessage.call((this._client || this.guild.shard.client), this.id, messageID
);
    }

    /**
    * Unpin a message
    * @arg {String} messageID The ID of the message
    * @returns {Promise}
    */
    unpinMessage(messageID) {
        return (this._client || this.guild.shard.client).unpinMessage.call((this._client || this.guild.shard.client), this.id, messageID
);
    }

    /**
    * Get a list of users who reacted with a specific reaction
    * @arg {String} messageID The ID of the message
    * @arg {String} react ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Client" id="apidoc.element.eris.Client">
        function <span class="apidocSignatureSpan">eris.</span>Client
        <span class="apidocSignatureSpan">(all options are optional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Client extends EventEmitter {
<span class="apidocCodeCommentSpan">    /**
    * Create a Client
    * @arg {String} token bot token
    * @arg {Object} [options] Eris options (all options are optional)
    * @arg {Boolean} [options.autoreconnect=true] Have Eris autoreconnect when connection is lost
    * @arg {Boolean} [options.compress=true] Whether to request WebSocket data to be compressed or not
    * @arg {Number} [options.connectionTimeout=30000] How long in milliseconds to wait for the connection to handshake with the
server
    * @arg {Object} [options.disableEvents] If disableEvents[eventName] is true, the WS event will not be processed. This can cause
 significant performance increase on large bots. [A full list of the WS event names can be found on the docs reference page](/Eris
/docs/reference#ws-event-names)
    * @arg {Boolean} [options.disableEveryone=true] When true, filter out @everyone/@here by default in createMessage/editMessage
    * @arg {Number} [options.firstShardID=0] The ID of the first shard to run for this client
    * @arg {Boolean} [options.getAllUsers=false] Get all the users in every guild. Ready time will be severely delayed
    * @arg {Number} [options.guildCreateTimeout=2000] How long in milliseconds to wait for a GUILD_CREATE before &#x22;ready&#x22; is fired
. Increase this value if you notice missing guilds
    * @arg {Number} [options.largeThreshold=250] The maximum number of offline users per guild during initial guild data transmission
    * @arg {Number} [options.lastShardID=options.maxShards - 1] The ID of the last shard to run for this client
    * @arg {Number} [options.maxShards=1] The total number of shards you want to run
    * @arg {Number} [options.messageLimit=100] The maximum size of a channel message cache
    * @arg {Boolean} [options.opusOnly=false] Whether to suppress the node-opus not found error or not
    * @arg {Boolean} [options.restMode=false] Whether to enable getting objects over REST. This should only be enabled if you are
 not connecting to the gateway. Bot tokens must be prefixed manually in REST mode
    * @arg {Boolean} [options.seedVoiceConnections=false] Whether to populate bot.voiceConnections with existing connections the
 bot account has during startup. Note that this will disconnect connections from other bot sessions
    * @arg {Number} [options.sequencerWait=200] How long to wait between sending potentially ratelimited requests. This number should
 be at least 3/4 your ping (in milliseconds)
    * @arg {Number} [options.state=true] Whether to enable state tracking. If state is false, no objects will be cached
    * @arg {String} [options.defaultImageFormat=&#x22;jpg&#x22;] The default format to provide user avatars, guild icons, and group icons
in. Can be &#x22;jpg&#x22;, &#x22;png&#x22;, &#x22;gif&#x22;, or &#x22;webp&#x22;
    * @arg {Number} [options.defaultImageSize=128] The default size to return user avatars, guild icons, and group icons as. Can
 be 128, 256, 512, 1024, or 2048.
    */
</span>    constructor(token, options) {
        super();

        this.options = {
            autoreconnect: true,
            compress: true,
            connectionTimeout: 30000,
            disableEvents: {},
            disableEveryone: true,
            firstShardID: 0,
            getAllUsers: false,
            guildCreateTimeout: 2000,
            largeThreshold: 250,
            maxShards: 1,
            messageLimit: 100,
            opusOnly: false,
            restMode: false,
            seedVoiceConnections: false,
            sequencerWait: 200,
            defaultImageFormat: &#x22;jpg&#x22;,
            defaultImageSize: 128
        };
        if(typeof options === &#x22;object&#x22;) {
            for(var property of Object.keys(options)) {
                this.options[property] = options[property];
            }
        }
        if(this.options.lastShardID === undefined) {
            this.options.lastShardID = this.options.maxShards - 1;
        }
        if(typeof window !== &#x22;undefined&#x22;) {
            try {
                require(&#x22;pako&#x22;);
            } catch(err) {
                this.options.compress = false; // zlib does not like Blobs, Pako i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Collection" id="apidoc.element.eris.Collection">
        function <span class="apidocSignatureSpan">eris.</span>Collection
        <span class="apidocSignatureSpan">(baseObject, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Collection extends Map {
<span class="apidocCodeCommentSpan">    /**
    * Construct a Collection
    * @arg {Class} baseObject The base class for all items
    * @arg {Number} [limit] Max number of items to hold
    */
</span>    constructor(baseObject, limit) {
        super();
        this.baseObject = baseObject;
        this.limit = limit;
    }

    /**
    * Add an object
    * @arg {Object} obj The object data
    * @arg {String} obj.id The ID of the object
    * @arg {Class?} extra An extra parameter the constructor may need
    * @arg {Boolean} replace Whether to replace an existing object with the same ID
    * @returns {Class} The existing or newly created object
    */
    add(obj, extra, replace) {
        if(this.limit === 0) {
            return (obj instanceof this.baseObject) ? obj : new this.baseObject(obj, extra);
        }
        if(obj.id == null) {
            throw new Error(&#x22;Missing object id&#x22;);
        }
        var existing = this.get(obj.id);
        if(existing &#x26;&#x26; !replace) {
            return existing;
        }
        if(!(obj instanceof this.baseObject)) {
            obj = new this.baseObject(obj, extra);
        }

        this.set(obj.id, obj);

        if(this.limit &#x26;&#x26; this.size &#x3e; this.limit) {
            var iter = this.keys();
            while(this.size &#x3e; this.limit) {
                this.delete(iter.next().value);
            }
        }
        return obj;
    }

    /**
    * Return the first object to make the function evaluate true
    * @arg {function} func A function that takes an object and returns true if it matches
    * @returns {Class?} The first matching object, or undefined if no match
    */
    find(func) {
        for(var item of this.values()) {
            if(func(item)) {
                return item;
            }
        }
        return undefined;
    }

    /**
    * Get a random object from the Collection
    * @returns {Class?} The random object, or undefined if there is no match
    */
    random() {
        if(!this.size) {
            return undefined;
        }
        return Array.from(this.values())[Math.floor(Math.random() * this.size)];
    }

    /**
    * Return all the objects that make the function evaluate true
    * @arg {function} func A function that takes an object and returns true if it matches
    * @returns {Array&#x3c;Class&#x3e;} An array containing all the objects that matched
    */
    filter(func) {
        var arr = [];
        for(var item of this.values()) {
            if(func(item)) {
                arr.push(item);
            }
        }
        return arr;
    }

    /**
    * Return an array with the results of applying the given function to each element
    * @arg {function} func A function that takes an object and returns something
    * @returns {Array} An array containing the results
    */
    map(func) {
        var arr = [];
        for(var item of this.values()) {
            arr.push(func(item));
        }
        return arr;
    }

    /**
    * Update an object
    * @arg {Object} obj The updated object data
    * @arg {String} obj.id The ID of the object
    * @arg {Class?} extra An extra parameter the constructor may need
    * @arg {Boolean} replace Whether to replace an existing object with the same ID
    * @returns {Class} The updated object
    */
    update(obj, extra, replace) {
        if(!obj.id &#x26;&#x26; obj.id !== 0) {
            throw new Error(&#x22;Missing object id&#x22;);
        }
        var item = this.get(obj.id);
        if(!item) {
            return this.add(obj, extra, replace);
        }
        item.update(obj, extra);
        return item;
    }

    /**
    * Remove an object
    * @arg {Object} obj The object
    * @arg {String} obj.id The ID of the object
    * @returns {Class?} The removed object, or null if nothing was removed
    */
    remove(obj) {
        var item = this.get(obj.id);
        if(!item) {
            return null;
        }
        this.delete(obj.id);
        return item;
    }

    toString() {
        return `[Collection&#x3c;${this.baseObject.name}&#x3e;]`;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Command" id="apidoc.element.eris.Command">
        function <span class="apidocSignatureSpan">eris.</span>Command
        <span class="apidocSignatureSpan">(msg, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Command {
<span class="apidocCodeCommentSpan">    /**
    * Register a command
    * @arg {String} label The command label
    * @arg {Function | String | Array&#x3c;Function | String&#x3e;} generator A response string, array of functions or strings, or function
 that generates a string or array of strings when called.
    * If a function is passed, the function will be passed a Message object and an array of command arguments. The Message object
 will have an additional property `prefix`, which is the prefix used in the command.
    * `generator(msg, args)`
    * @arg {Object} [options] Command options
    * @arg {Array&#x3c;String&#x3e;} [options.aliases] An array of command aliases
    * @arg {Boolean} [options.caseInsensitive=false] Whether the command label (and aliases) is case insensitive or not
    * @arg {Boolean} [options.deleteCommand=false] Whether to delete the user command message or not
    * @arg {Boolean} [options.argsRequired=false] If arguments are required or not
    * @arg {Boolean} [options.guildOnly=false] Whether to prevent the command from being used in Direct Messages or not
    * @arg {Boolean} [options.dmOnly=false] Whether to prevent the command from being used in guilds or not
    * @arg {String} [options.description=&#x22;No description&#x22;] A short description of the command to show in the default help command
    * @arg {String} [options.fullDescription=&#x22;No full description&#x22;] A detailed description of the command to show in the default
 help command
    * @arg {String} [options.usage] Details on how to call the command to show in the default help command
    * @arg {Object} [options.requirements] A set of factors that limit who can call the command
    * @arg {Array&#x3c;String&#x3e;} [options.requirements.userIDs] An array of user IDs representing users that can call the command
    * @arg {Object} [options.requirements.permissions] An object containing permission keys the user must match to use the command
    * i.e.:
    * ```
    * {
    *   &#x22;administrator&#x22;: false,
    *   &#x22;manageMessages&#x22;: true
    * }
    * ```
    * In the above example, the user must not have administrator permissions, but must have manageMessages to use the command
    * @arg {Array&#x3c;String&#x3e;} [options.requirements.roleIDs] An array of role IDs that would allow a user to use the command
    * @arg {Array&#x3c;String&#x3e;} [options.requirements.roleNames] An array of role names that would allow a user to use the command
    * @arg {Number} [options.cooldown] The cooldown between command usage in milliseconds
    * @arg {String} [options.cooldownMessage] A message to show when the command is on cooldown
    * @arg {String} [options.permissionMessage] A message to show when the user doesn&#x27;t have permissions to use the command
    * @arg {String} [options.errorMessage] A message to show if the execution of the command handler somehow fails.
    */
</span>    constructor(label, generator, options) {
        this.label = label;
        this.description = options.description || &#x22;No description&#x22;;
        this.fullDescription = options.fullDescription || &#x22;No full description&#x22;;
        this.usage = options.usage || &#x22;&#x22;;
        this.aliases = options.aliases || [];
        this.caseInsensitive = !!options.caseInsensitive;
        this.requirements = options.requirements || {};
        if(!this.requirements.userIDs) {
            this.requirements.userIDs = [];
        }
        if(!this.requirements.permissions) {
            this.requirements.permissions = {};
        }
        if(!this.requirements.roleIDs) {
            this.requirements.roleIDs = [];
        }
        if(!this.requirements.roleNames) {
            this.requirements.roleNames = [];
        }
        this.deleteCommand = !!options.deleteCommand;
        this.argsRequired = !!options.argsRequired;
        this.guildOnly = !!options.guildOnly;
        this.dmOnly = !!options.dmOnly;
        this.cooldown = options.cooldown || 0;
        this.cooldownMessage = options.cooldownMessage || false;
        this.permissionMessage = options.permissionMessage || false;
        this.errorMessage = options.errorMessage || &#x22;&#x22;;
        if(this.cooldown ! ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.CommandClient" id="apidoc.element.eris.CommandClient">
        function <span class="apidocSignatureSpan">eris.</span>CommandClient
        <span class="apidocSignatureSpan">(same as Client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CommandClient extends Client {
<span class="apidocCodeCommentSpan">    /**
    * Create a CommandClient
    * @arg {String} token bot token
    * @arg {Object} [options] Eris options (same as Client)
    * @arg {Object} [commandOptions] Command options
    * @arg {Boolean} [commandOptions.defaultHelpCommand=true] Whether to register the default help command or not
    * @arg {String} [commandOptions.description=&#x22;An Eris-based Discord bot&#x22;] The description to show in the default help command
    * @arg {Boolean} [commandOptions.ignoreBots=true] Whether to ignore bot accounts or not
    * @arg {Boolean} [commandOptions.ignoreSelf=true] Whether to ignore the bot&#x27;s own account or not
    * @arg {String} [commandOptions.name=&#x22;&#x3c;Bot username&#x3e;&#x22;] The bot name to show in the default help command
    * @arg {String} [commandOptions.owner=&#x22;an unknown user&#x22;] The owner to show in the default help command
    * @arg {String|Array} [commandOptions.prefix=&#x22;@mention &#x22;] The bot prefix. Can be either an array of prefixes or a single prefix
. &#x22;@mention&#x22; will be automatically replaced with the bot&#x27;s actual mention
    * @arg {Object} [commandOptions.defaultCommandOptions={}] Default command options. This object takes the same options as a normal
 Command
    */
</span>    constructor(token, options, commandOptions) {
        super(token, options);
        this.commandOptions = {
            defaultHelpCommand: true,
            description: &#x22;An Eris-based Discord bot&#x22;,
            ignoreBots: true,
            ignoreSelf: true,
            name: null,
            owner: &#x22;an unknown user&#x22;,
            prefix: &#x22;@mention &#x22;,
            defaultCommandOptions: {}
        };
        if(typeof commandOptions === &#x22;object&#x22;) {
            for(var property of Object.keys(commandOptions)) {
                this.commandOptions[property] = commandOptions[property];
            }
        }
        this.guildPrefixes = {};
        this.commands = {};
        this.commandAliases = {};

        this.once(&#x22;shardPreReady&#x22;, () =&#x3e; {
            this.preReady = true;
            if(!this.commandOptions.name) {
                this.commandOptions.name = `**${this.user.username}**`;
            }
            if(Array.isArray(this.commandOptions.prefix)){
                for(let i in this.commandOptions.prefix){
                    this.commandOptions.prefix[i] = this.commandOptions.prefix[i].replace(/@mention/g, this.user.mention);
                }
            } else {
                this.commandOptions.prefix = this.commandOptions.prefix.replace(/@mention/g, this.user.mention);
            }
            for(var key in this.guildPrefixes) {
                if(Array.isArray(this.guildPrefixes[key])){
                    for(let i in this.guildPrefixes[key]){
                        this.guildPrefixes[key][i] = this.guildPrefixes[key][i].replace(/@mention/g, this.user.mention);
                    }
                } else {
                    this.guildPrefixes[key] = this.guildPrefixes[key].replace(/@mention/g, this.user.mention);
                }
            }
        });

        this.on(&#x22;messageCreate&#x22;, this.onMessageCreate);

        if(this.commandOptions.defaultHelpCommand) {
            this.registerCommand(&#x22;help&#x22;, (msg, args) =&#x3e; {
                var result = &#x22;&#x22;;
                if(args.length &#x3e; 0) {
                    var cur = this.commands[this.commandAliases[args[0]] || args[0]];
                    if(!cur) {
                        return &#x22;Command not found&#x22;;
                    }
                    var label = cur.label;
                    for(var i = 1; i &#x3c; args.length; ++i) {
                        cur = cur.subcommands[cur.subcommandAliases[args[i]] || args[i]];
                        if(!cur) {
                            return &#x22;Command not found&#x22;;
                        }
                        label += &#x22; &#x22; + cur.label;
                    }
                    result += `**${msg.prefix}${label}** ${cur.usage}\n${cur.fullDescription}`;
                    if(Object.keys(cur.aliases).length &#x3e; 0) {
                        result += `\n\n**Aliases:** ${cur.aliases.join(&#x22;, &#x22;)} ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.ExtendedUser" id="apidoc.element.eris.ExtendedUser">
        function <span class="apidocSignatureSpan">eris.</span>ExtendedUser
        <span class="apidocSignatureSpan">(data, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ExtendedUser extends User {
    constructor(data, client) {
        super(data, client);
        this.update(data);
    }

    update(data) {
        super.update(data);
        this.email = data.email !== undefined ? data.email : this.email;
        this.verified = data.verified !== undefined ? data.verified : this.verified;
        this.mfaEnabled = data.mfa_enabled !== undefined ? data.mfa_enabled : this.mfaEnabled;
        this.premium = data.premium !== undefined ? data.premium : this.premium;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.FFmpegDuplex" id="apidoc.element.eris.FFmpegDuplex">
        function <span class="apidocSignatureSpan">eris.</span>FFmpegDuplex
        <span class="apidocSignatureSpan">(command, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class FFmpegDuplex extends DuplexStream {
    constructor(command, options) {
        options = options || {};
        if(options.highWaterMark === undefined) {
            options.highWaterMark = 0;
        }
        super(options);

        this.command = command;
        this._reader = new PassThroughStream(options);
        this._writer = new PassThroughStream(options);

        this._onError = this.emit.bind(this, &#x22;error&#x22;);

        this._reader.on(&#x22;error&#x22;, this._onError);
        this._writer.on(&#x22;error&#x22;, this._onError);

        this._readableState = this._reader._readableState;
        this._writableState = this._writer._writableState;

        [&#x22;on&#x22;, &#x22;once&#x22;, &#x22;removeListener&#x22;, &#x22;removeListeners&#x22;, &#x22;listeners&#x22;].forEach((method) =&#x3e; {
            var og = DuplexStream.prototype[method];

            this[method] = function(ev, fn) {
                var substream = delegateEvents[ev];
                if (substream) {
                    return this[substream][method](ev, fn);
                } else {
                    return og.call(this, ev, fn);
                }
            };
        });
    }

    spawn(args, options) {
        options = options || {};
        var ex, exited, killed, ended;
        var stderr = [];

        var onStdoutEnd = () =&#x3e; {
            if (exited &#x26;&#x26; !ended) {
                ended = true;
                this._reader.end();
                setImmediate(this.emit.bind(this, &#x22;close&#x22;));
            }
        };

        var onStderrData = (chunk) =&#x3e; {
            stderr.push(chunk);
        };

        var onExit = (code, signal) =&#x3e; {
            if(exited) {
                return;
            }
            exited = true;

            if (killed) {
                if (ex) {
                    this.emit(&#x22;error&#x22;, ex);
                }
                this.emit(&#x22;close&#x22;);
            } else if (code === 0 &#x26;&#x26; signal == null) {
                // All is well
                onStdoutEnd();
            } else {
                // Everything else
                ex = new Error(&#x22;Command failed: &#x22; + Buffer.concat(stderr).toString(&#x22;utf8&#x22;));
                ex.killed = this._process.killed || killed;
                ex.code = code;
                ex.signal = signal;
                this.emit(&#x22;error&#x22;, ex);
                this.emit(&#x22;close&#x22;);
            }

            cleanup();
        };

        var onError = (err) =&#x3e; {
            ex = err;
            this._stdout.destroy();
            this._stderr.destroy();
            onExit();
        };

        var kill = () =&#x3e; {
            if(killed) {
                return;
            }
            this._stdout.destroy();
            this._stderr.destroy();

            killed = true;

            try {
                this._process.kill(options.killSignal || &#x22;SIGTERM&#x22;);
                setTimeout(() =&#x3e; this._process &#x26;&#x26; this._process.kill(&#x22;SIGKILL&#x22;), 2000);
            } catch (e) {
                ex = e;
                onExit();
            }
        };

        var cleanup = () =&#x3e; {
            this._process =
            this._stderr =
            this._stdout =
            this._stdin =
            stderr =
            ex =
            killed = null;

            this.kill =
            this.destroy = this.noop;
        };

        this._process = ChildProcess.spawn(this.command, args, options);
        this._stdin = this._process.stdin;
        this._stdout = this._process.stdout;
        this._stderr = this._process.stderr;
        this._writer.pipe(this._stdin);
        this._stdout.pipe(this._reader, {
            end: false
        });
        this.kill = this.destroy = kill;

        // this._stderr.pipe(process.stderr);
        this._stderr.on(&#x22;data&#x22;, onStderrData);

        // In some cases ECONNRESET can be emitted by stdin because the process is not interested in any
        // more data but the _writer is still piping. Forget about errors emitted on stdin and stdout
        this._stdin.on(&#x22;error&#x22;, this.noop);
        this._stdout.on(&#x22;error&#x22;, this.noop);

        this._stdout.on(&#x22;end&#x22;, onStdoutEnd);

        this._process.once(&#x22;close&#x22; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.GroupChannel" id="apidoc.element.eris.GroupChannel">
        function <span class="apidocSignatureSpan">eris.</span>GroupChannel
        <span class="apidocSignatureSpan">(╯°□°）╯︵ ┻━┻ constructor(data, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class GroupChannel extends PrivateChannel { // (╯°□°）╯︵ ┻━┻ constructor(data, client) {
        super(data, client);
        this.recipients = new Collection(User);
        data.recipients.forEach((recipient) =&#x3e; {
            this.recipients.add(client.options.restMode ? new User(recipient, client) : client.users.add(recipient, client));
        });
        this.update(data);
    }

    update(data) {
        this.name = data.name !== undefined ? data.name : this.name;
        this.ownerID = data.owner_id !== undefined ? data.owner_id : this.ownerID;
        this.icon = data.icon !== undefined ? data.icon : this.icon;
    }

<span class="apidocCodeCommentSpan">    /**
    * Edit the channel&#x27;s properties
    * @arg {Object} options The properties to edit
    * @arg {String} [options.name] The name of the channel
    * @arg {String} [options.icon] The icon of the channel as a base64 data URI (group channels only). Note: base64 strings alone
 are not base64 data URI strings
    * @arg {String} [options.ownerID] The ID of the channel owner (group channels only)
    * @returns {Promise&#x3c;GroupChannel&#x3e;}
    */
</span>    edit(options) {
        return this._client.editChannel.call(this._client, this.id, options);
    }

    /**
    * Add a user to the group
    * @arg {String} userID The ID of the target user
    * @returns {Promise}
    */
    addRecipient(userID) {
        return this._client.addGroupRecipient.call(this._client, this.id, userID);
    }

    /**
    * Remove a user from the group
    * @arg {String} userID The ID of the target user
    * @returns {Promise}
    */
    removeRecipient(userID) {
        return this._client.removeGroupRecipient.call(this._client, this.id, userID);
    }

    get iconURL() {
        return this.icon ? `${Endpoints.CDN_URL}/channel-icons/${this.id}/${this.icon}.${this._client.options.defaultImageFormat
}?size=${this._client.options.defaultImageSize}` : null;
    }

    /**
    * Get the group&#x27;s icon with the given format and size
    * @arg {String} [format] The filetype of the icon (&#x22;jpg&#x22;, &#x22;png&#x22;, &#x22;gif&#x22;, or &#x22;webp&#x22;)
    * @arg {Number} [size] The size of the icon (128, 256, 512, 1024, 2048)
    */
    dynamicIconURL(format, size) {
        if(format === undefined || !~Constants.ImageFormats.indexOf(format.toLowerCase())) {
            format = this._client.options.defaultImageFormat;
        }
        if(size === undefined || !~Constants.ImageSizes.indexOf(size)) {
             size = this._client.options.defaultImageSize;
        }
        return this.icon ? `${Endpoints.CDN_URL}/channel-icons/${this.id}/${this.icon}.${format}?size=${size}` : null;
     }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Guild" id="apidoc.element.eris.Guild">
        function <span class="apidocSignatureSpan">eris.</span>Guild
        <span class="apidocSignatureSpan">(data, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Guild extends Base {
    constructor(data, client) {
        super(data.id);
        this.shard = client.shards.get(client.guildShardMap[this.id]);
        this.unavailable = !!data.unavailable;
        this.joinedAt = Date.parse(data.joined_at);
        this.channels = new Collection(GuildChannel);
        this.members = new Collection(Member);
        this.memberCount = data.member_count;
        this.roles = new Collection(Role);

        for(var role of data.roles) {
            this.roles.add(role, this);
        }

        if(data.channels) {
            for(var channel of data.channels) {
                channel = this.channels.add(channel, this);
                client.channelGuildMap[channel.id] = this.id;
            }

            this.defaultChannel = this.channels.get(this.id);
        }

        if(data.members) {
            for(var member of data.members) {
                member.id = member.user.id;
                this.members.add(member, this);
            }
        }

        if(data.presences) {
            for(var presence of data.presences) {
                if(!this.members.get(presence.user.id)) {
                    var userData = client.users.get(presence.user.id);
                    if(userData) {
                        userData = `{username: ${userData.username}, id: ${userData.id}, discriminator: ${userData.discriminator
}}`;
                    }
                    client.emit(&#x22;debug&#x22;, `Presence without member. ${presence.user.id}. In global user cache: ${userData}. ` + JSON
.stringify(presence), this.shard.id);
                    continue;
                }
                presence.id = presence.user.id;
                this.members.update(presence);
            }
        }

        if(data.voice_states) {
            if(!client.bot) {
                this.pendingVoiceStates = data.voice_states;
            } else {
                for(var voiceState of data.voice_states) {
                    if(!this.members.get(voiceState.user_id)) {
                        continue;
                    }
                    voiceState.id = voiceState.user_id;
                    try {
                        this.channels.get(voiceState.channel_id).voiceMembers.add(this.members.update(voiceState));
                    } catch(err) {
                        client.emit(&#x22;error&#x22;, err, this.shard.id);
                        continue;
                    }
                    if(client.options.seedVoiceConnections &#x26;&#x26; voiceState.id === client.user.id &#x26;&#x26; !client.voiceConnections.get(this
.id)) {
                        process.nextTick(() =&#x3e; this.shard.client.joinVoiceChannel(voiceState.channel_id, false));
                    }
                }
            }
        }
        this.update(data);
    }

    update(data) {
        this.name = data.name !== undefined ? data.name : this.name;
        this.verificationLevel = data.verification_level !== undefined ? data.verification_level : this.verificationLevel;
        this.splash = data.splash !== undefined ? data.splash : this.splash;
        this.region = data.region !== undefined ? data.region : this.region;
        this.ownerID = data.owner_id !== undefined ? data.owner_id : this.ownerID;
        this.icon = data.icon !== undefined ? data.icon : this.icon;
        this.features = data.features !== undefined ? data.features : this.features; // TODO parse features
        this.emojis = data.emojis !== undefined ? data.emojis : this.emojis; // TODO parse emojis
        this.afkChannelID = data.afk_channel_id !== undefined ? data.afk_channel_id : this.afkChannelID;
        this.afkTimeout = data.afk_timeout !== undefined ? data.afk_timeout : this.afkTimeout;
        this.defaultNotifications = data.default_message_notifications !== undefined ? data.default_message_notifications : this
.defaultNotifications;
        this.mfaLevel = data.mfa_level !== undefined ? data.mfa_level : this.mfaLevel;
        this.large = data.large !== undefined ? data.large : this.large;
        this.maxPresences = data.max_presences !== undefined ? data.max_presences : t ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.GuildChannel" id="apidoc.element.eris.GuildChannel">
        function <span class="apidocSignatureSpan">eris.</span>GuildChannel
        <span class="apidocSignatureSpan">(data, guild, messageLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class GuildChannel extends Channel {
    constructor(data, guild, messageLimit) {
        super(data);
        this.guild = guild;
        if(this.type === 2) {
            this.voiceMembers = new Collection(Member);
        } else {
            if(messageLimit == null &#x26;&#x26; guild) {
                messageLimit = guild.shard.client.options.messageLimit;
            }
            this.messages = new Collection(Message, messageLimit);
            this.lastMessageID = data.last_message_id || null;
            this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
        }
        this.update(data);
    }

    update(data) {
        this.name = data.name !== undefined ? data.name : this.name;
        this.topic = data.topic !== undefined ? data.topic : this.topic;
        this.position = data.position !== undefined ? data.position : this.position;
        this.bitrate = data.bitrate !== undefined ? data.bitrate : this.bitrate;
        this.userLimit = data.user_limit !== undefined ? data.user_limit : this.userLimit;
        if(data.permission_overwrites) {
            this.permissionOverwrites = new Collection(PermissionOverwrite);
            data.permission_overwrites.forEach((overwrite) =&#x3e; {
                this.permissionOverwrites.add(overwrite);
            });
        }
    }

<span class="apidocCodeCommentSpan">    /**
    * Get the channel-specific permissions of a member
    * @arg {String} memberID The ID of the member
    * @returns {Permission}
    */
</span>    permissionsOf(memberID) {
        var member = this.guild.members.get(memberID);
        var permission = member.permission.allow;
        if(permission &#x26; Permissions.administrator) {
            return new Permission(Permissions.all);
        }
        var deny = 0;
        var allow = 0;
        for(var overwrite of this.permissionOverwrites) {
            if(overwrite[1].type === &#x22;role&#x22; &#x26;&#x26; (overwrite[1].id === this.guild.id || ~member.roles.indexOf(overwrite[1].id))) {
                deny |= overwrite[1].deny;
                allow |= overwrite[1].allow;
            }
        }
        permission = (permission &#x26; ~deny) | allow;
        var memberOverwrite = this.permissionOverwrites.get(memberID);
        if(memberOverwrite) {
            permission = (permission &#x26; ~memberOverwrite.deny) | memberOverwrite.allow;
        }
        return new Permission(permission);
    }

    get mention() {
        return `&#x3c;#${this.id}&#x3e;`;
    }

    /**
    * Edit the channel&#x27;s properties
    * @arg {Object} options The properties to edit
    * @arg {String} [options.name] The name of the channel
    * @arg {String} [options.topic] The topic of the channel (guild text channels only)
    * @arg {Number} [options.bitrate] The bitrate of the channel (guild voice channels only)
    * @arg {Number} [options.userLimit] The channel user limit (guild voice channels only)
    * @returns {Promise&#x3c;GuildChannel&#x3e;}
    */
    edit(options) {
        return this.guild.shard.client.editChannel.call(this.guild.shard.client, this.id, options);
    }

    /**
    * Edit the channel&#x27;s position. Note that channel position numbers are lowest on top and highest at the bottom.
    * @arg {Number} position The new position of the channel
    * @returns {Promise}
    */
    editPosition(position) {
        return this.guild.shard.client.editChannelPosition.call(this.guild.shard.client, this.id, position);
    }

    /**
    * Delete the channel
    * @returns {Promise}
    */
    delete() {
        return this.guild.shard.client.deleteChannel.call(this.guild.shard.client, this.id);
    }

    /**
    * Create a channel permission overwrite
    * @arg {String} overwriteID The ID of the overwritten user or role
    * @arg {Number} allow The permissions number for allowed permissions
    * @arg {Number} deny The permissions number for denied permissions
    * @arg {String} type The object type of the overwrite, either &#x22;member&#x22; or &#x22;role&#x22;
    * @returns {Promise&#x3c;PermissionOverwrite&#x3e;}
    */
    editPermission(overwriteID, allow, deny, type) {
        return this.guild.shard.client.editChannelPermission ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.GuildIntegration" id="apidoc.element.eris.GuildIntegration">
        function <span class="apidocSignatureSpan">eris.</span>GuildIntegration
        <span class="apidocSignatureSpan">(data, guild)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class GuildIntegration extends Base {
    constructor(data, guild) {
        super(data.id);
        this.guild = guild;
        this.name = data.name;
        this.type = data.type;
        this.roleID = data.role_id;
        this.user = guild.shard.client.users.add(data.user, guild.shard.client);
        this.account = data.account; // not worth making a class for
        this.update(data);
    }

    update(data) {
        this.enabled = data.enabled;
        this.syncing = data.syncing;
        this.expireBehavior = data.expire_behavior;
        this.expireGracePeriod = data.expire_grace_period;
        this.enableEmoticons = data.enable_emoticons;
        this.subscriberCount = data.subscriber_count;
        this.syncedAt = data.synced_at;
    }

<span class="apidocCodeCommentSpan">    /**
    * Edit the guild integration
    * @arg {Object} options The properties to edit
    * @arg {String} [options.expireBehavior] What to do when a user&#x27;s subscription runs out
    * @arg {String} [options.expireGracePeriod] How long before the integration&#x27;s role is removed from an unsubscribed user
    * @arg {String} [options.enableEmoticons] Whether to enable integration emoticons or not
    * @returns {Promise}
    */
</span>    edit(options) {
        return this.guild.shard.client.editGuildIntegration.call(this.guild.shard.client, this.guild.id, this.id, options);
    }

    /**
    * Delete the guild integration
    * @returns {Promise}
    */
    delete() {
        return this.guild.shard.client.deleteGuildIntegration.call(this.guild.shard.client, this.guild.id, this.id);
    }

    /**
    * Force the guild integration to sync
    * @returns {Promise}
    */
    sync() {
        return this.guild.shard.client.syncGuildIntegration.call(this.guild.shard.client, this.guild.id, this.id);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Invite" id="apidoc.element.eris.Invite">
        function <span class="apidocSignatureSpan">eris.</span>Invite
        <span class="apidocSignatureSpan">(data, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Invite extends Base {
    constructor(data, client) {
        super();
        this._client = client;
        this.code = data.code;
        this.channel = data.channel;
        this.guild = {
            splash: data.guild.splash,
            icon: data.guild.icon,
            id: data.guild.id,
            name: data.guild.name
        };
        if(data.inviter) {
            this.inviter = client.users.add(data.inviter, client);
        }
        this.uses = data.uses !== undefined ? data.uses : null;
        this.maxUses = data.max_uses !== undefined ? data.max_uses : null;
        this.maxAge = data.max_age !== undefined ? data.max_age : null;
        this.temporary = data.temporary !== undefined ? data.temporary : null;
        this._createdAt = data.created_at !== undefined ? data.created_at : null;
        this.revoked = data.revoked !== undefined ? data.revoked : null;
    }

    get createdAt() {
        return this._createdAt;
    }

<span class="apidocCodeCommentSpan">    /**
    * Delete the invite
    * @returns {Promise}
    */
</span>    delete() {
        return this._client.deleteInvite.call(this._client, this.code);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Member" id="apidoc.element.eris.Member">
        function <span class="apidocSignatureSpan">eris.</span>Member
        <span class="apidocSignatureSpan">(data, guild)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Member extends Base {
    constructor(data, guild) {
        super(data.id);
        if((this.guild = guild)) {
            this.user = guild.shard.client.users.get(data.id);
            if(!this.user &#x26;&#x26; data.user) {
                this.user = guild.shard.client.users.add(data.user, guild.shard.client);
            }
            if(!this.user) {
                throw new Error(&#x22;User associated with Member not found: &#x22; + data.id);
            }
        } else {
            this.user = null;
        }
        this.voiceState = new VoiceState(data);
        this.update(data);
    }

    update(data) {
        this.status = data.status !== undefined ? data.status : this.status || &#x22;offline&#x22;;
        this.game = data.game !== undefined ? data.game : this.game || null;
        this.joinedAt = data.joined_at !== undefined ? Date.parse(data.joined_at) : this.joinedAt;

        if(data.mute !== undefined) {
            this.voiceState.update(data);
        }

        this.nick = data.nick !== undefined ? data.nick : this.nick || null;
        if(data.roles !== undefined) {
            this.roles = data.roles;
        }
    }

    get permission() {
        if(this.id === this.guild.ownerID) {
            return new Permission(Permissions.all);
        } else {
            var permissions = this.guild.roles.get(this.guild.id).permissions.allow;
            for(var role of this.roles) {
                role = this.guild.roles.get(role);
                if(!role) {
                    continue;
                }

                var perm = role.permissions.allow;
                if(perm &#x26; Permissions.administrator) {
                    permissions = Permissions.all;
                    break;
                } else {
                    permissions |= perm;
                }
            }
            return new Permission(permissions);
        }
    }

    get username() {
        return this.user.username;
    }

    get discriminator() {
        return this.user.discriminator;
    }

    get avatar() {
        return this.user.avatar;
    }

    get bot() {
        return this.user.bot;
    }

    get createdAt() {
        return this.user.createdAt;
    }

    get defaultAvatar() {
        return this.user.defaultAvatar;
    }

    get defaultAvatarURL() {
        return this.user.defaultAvatarURL;
    }

    get staticAvatarURL(){
        return this.user.staticAvatarURL;
    }

    get avatarURL() {
        return this.user.avatarURL;
    }

    get mention() {
        return `&#x3c;@!${this.id}&#x3e;`;
    }

<span class="apidocCodeCommentSpan">    /**
    * Edit the guild member
    * @arg {Object} options The properties to edit
    * @arg {String[]} [options.roles] The array of role IDs the user should have
    * @arg {String} [options.nick] Set the user&#x27;s server nickname, &#x22;&#x22; to remove
    * @arg {Boolean} [options.mute] Server mute the user
    * @arg {Boolean} [options.deaf] Server deafen the user
    * @arg {String} [options.channelID] The ID of the voice channel to move the user to (must be in voice)
    * @returns {Promise}
    */
</span>    edit(options) {
        return this.guild.shard.client.editGuildMember.call(this.guild.shard.client, this.guild.id, this.id, options);
    }

    /**
    * Add a role to the guild member
    * @arg {String} roleID The ID of the role
    * @returns {Promise}
    */
    addRole(roleID) {
        return this.guild.shard.client.addGuildMemberRole.call(this.guild.shard.client, this.guild.id, this.id, roleID);
    }

    /**
    * Remve a role from the guild member
    * @arg {String} roleID The ID of the role
    * @returns {Promise}
    */
    removeRole(roleID) {
        return this.guild.shard.client.removeGuildMemberRole.call(this.guild.shard.client, this.guild.id, this.id, roleID);
    }

    /**
    * Kick the member from the guild
    * @returns {Promise}
    */
    kick() {
        return this.guild.shard.client.kickGuildMember.call(this.guild.shard.client, this.guild.id, this.id);
    }

    /**
    * Ban the user from the guild
    * @arg {Number} [deleteMessageDays=0] Number of days to delete messages for
    * @returns { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Message" id="apidoc.element.eris.Message">
        function <span class="apidocSignatureSpan">eris.</span>Message
        <span class="apidocSignatureSpan">(data, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Message extends Base {
    constructor(data, client) {
        super(data.id);
        this._client = client;
        this.type = data.type;
        this.timestamp = Date.parse(data.timestamp);
        this.channel = client.getChannel(data.channel_id) || {
            id: data.channel_id
        };
        this.content = &#x22;&#x22;;
        this.hit = !!data.hit;
        this.reactions = {};
        if(data.author) {
            if(data.author.discriminator !== &#x22;0000&#x22;) {
                this.author = client.users.add(data.author);
            } else {
                this.author = new User(data.author, client);
            }
        } else if(data.timestamp) {
            this._client.emit(&#x22;warn&#x22;, &#x22;MESSAGE_CREATE but no message author:\n&#x22; + JSON.stringify(data, null, 2));
        }
        if(this.type === 0 || this.type === undefined);
        else if(this.type === 1) {
            data.content = `${this.author.mention} added &#x3c;@${data.mentions[0].id}&#x3e;.`;
        } else if(this.type === 2) {
            if(this.author.id === data.mentions[0].id) {
                data.content = `@${this.author.username} left the group.`;
            } else {
                data.content = `${this.author.mention} removed @${data.mentions[0].username}.`;
            }
        } else if(this.type === 3) { // (╯°□°）╯︵ ┻━┻
            if(data.call.ended_timestamp) {
                if((!this.channel.lastCall || this.channel.lastCall.endedTimestamp &#x3c; Date.parse(data.call.ended_timestamp))) {
                    data.call.id = this.id;
                    this.channel.lastCall = new Call(data.call, this.channel);
                }
                if(~data.call.participants.indexOf(client.user.id)) {
                    data.content = `You missed a call from ${this.author.mention}.`;
                } else {
                    data.content = `${this.author.mention} started a call.`;
                }
            } else {
                if(!this.channel.call) {
                    data.call.id = this.id;
                    this.channel.call = new Call(data.call, this.channel);
                }
                data.content = `${this.author.mention} started a call. — Join the call.`;
            }
        } else if(this.type === 4) {
            data.content = `${this.author.mention} changed the channel name: ${data.content}`;
        } else if(this.type === 5) {
            data.content = `${this.author.mention} changed the channel icon.`;
        } else if(this.type === 6) {
            data.content = `${this.author.mention} pinned a message to this channel. See all the pins.`;
        } else {
            throw new Error(&#x22;Unhandled MESSAGE_CREATE type: &#x22; + JSON.stringify(data, null, 2));
        }

        this.update(data, client);
    }

    update(data, client) {
        if(this.type === 3) { // (╯°□°）╯︵ ┻━┻
            (this.channel.call || this.channel.lastCall).update(data.call);
        }
        if(data.content !== undefined) {
            this.content = data.content || &#x22;&#x22;;
            this._cleanContent = null;
            this.mentionEveryone = !!data.mention_everyone;

            this.mentions = data.mentions.map((mention) =&#x3e; client.users.add(mention, client));

            this.roleMentions = data.mention_roles;
        }

        this.pinned = data.pinned !== undefined ? !!data.pinned : this.pinned;
        this.editedTimestamp = data.edited_timestamp !== undefined ? Date.parse(data.edited_timestamp) : this.editedTimestamp;
        this.tts = data.tts !== undefined ? data.tts : this.tts;
        this.attachments = data.attachments !== undefined ? data.attachments : this.attachments; // TODO parse attachments
        this.embeds = data.embeds !== undefined ? data.embeds : this.embeds; // TODO parse embeds

        if(data.reactions) {
            data.reactions.forEach((reaction) =&#x3e; {
                this.reactions[reaction.emoji.id ? `${reaction.emoji.name}:${reaction.emoji.id}` : reaction.emoji.name] = {
                    count: reaction.count,
                    me: reaction.me
                };
            });
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Permission" id="apidoc.element.eris.Permission">
        function <span class="apidocSignatureSpan">eris.</span>Permission
        <span class="apidocSignatureSpan">(allow, deny)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Permission extends Base {
    constructor(allow, deny) {
        super();
        this.allow = allow;
        this.deny = deny || 0;
    }

    get json() {
        if(!this._json) {
            this._json = {};
            for(var perm of Object.keys(Permissions)) {
                if(!perm.startsWith(&#x22;all&#x22;)) {
                    if(this.allow &#x26; Permissions[perm]) {
                        this._json[perm] = true;
                    } else if(this.deny &#x26; Permissions[perm]) {
                        this._json[perm] = false;
                    }
                }
            }
        }
        return this._json;
    }

<span class="apidocCodeCommentSpan">    /**
    * Check if this permission allows a specific permission
    * @arg {String} permission The name of the permission. [A full list of permission nodes can be found on the docs reference page
](/Eris/docs/reference)
    * @returns {Boolean} Whether the permission allows the specified permission
    */
</span>    has(permission) {
        return !!(this.allow &#x26; Permissions[permission]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.PermissionOverwrite" id="apidoc.element.eris.PermissionOverwrite">
        function <span class="apidocSignatureSpan">eris.</span>PermissionOverwrite
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PermissionOverwrite extends Permission {
    constructor(data) {
        super(data.allow, data.deny);
        this.id = data.id;
        this.type = data.type;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.PrivateChannel" id="apidoc.element.eris.PrivateChannel">
        function <span class="apidocSignatureSpan">eris.</span>PrivateChannel
        <span class="apidocSignatureSpan">(data, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PrivateChannel extends Channel {
    constructor(data, client) {
        super(data);
        this._client = client;
        this.lastMessageID = data.last_message_id;
        this.call = this.lastCall = null;
        if(this.type === 1 || this.type === undefined) {
            this.recipient = new User(data.recipients[0], client);
        }
        this.messages = new Collection(Message, client.options.messageLimit);
    }

<span class="apidocCodeCommentSpan">    /**
    * Ring fellow group channel recipient(s)
    * @arg {String[]} recipients The IDs of the recipients to ring
    */
</span>    ring(recipients) {
        this._client.requestHandler.request(&#x22;POST&#x22;, Endpoints.CHANNEL_CALL_RING(this.id), true, {
            recipients
        });
    }

    /**
    * Check if the channel has an existing call
    */
    syncCall() {
        this._client.shards.values().next().value.sendWS(OPCodes.SYNC_CALL, {
            channel_id: this.id
        });
    }

    /**
    * Leave the channel
    * @returns {Promise}
    */
    leave() {
        return this._client.deleteChannel.call(this._client, this.id);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Relationship" id="apidoc.element.eris.Relationship">
        function <span class="apidocSignatureSpan">eris.</span>Relationship
        <span class="apidocSignatureSpan">(data, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Relationship extends Base {
    constructor(data, client) {
        super(data.id);
        this.user = client.users.add(data.user, client);
        this.update(data);
    }

    update(data) {
        this.type = data.type !== undefined ? data.type : this.type || 0;
        this.status = data.status !== undefined ? data.status : this.status || &#x22;offline&#x22;;
        this.game = data.game !== undefined ? data.game : this.game || null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Role" id="apidoc.element.eris.Role">
        function <span class="apidocSignatureSpan">eris.</span>Role
        <span class="apidocSignatureSpan">(data, guild)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Role extends Base {
    constructor(data, guild) {
        super(data.id);
        this.guild = guild;
        this.update(data);
    }

    update(data) {
        this.name = data.name !== undefined ? data.name : this.name;
        this.mentionable = data.mentionable !== undefined ? data.mentionable : this.mentionable;
        this.managed = data.managed !== undefined ? data.managed : this.managed;
        this.hoist = data.hoist !== undefined ? data.hoist : this.hoist;
        this.color = data.color !== undefined ? data.color : this.color;
        this.position = data.position !== undefined ? data.position : this.position;
        this.permissions = data.permissions !== undefined ? new Permission(data.permissions) : this.permissions;
    }

<span class="apidocCodeCommentSpan">    /**
    * Generates a JSON representation of the role permissions
    * @returns {Object}
    */
</span>    get json() {
        return this.permissions.json;
    }

    get mention() {
        return `&#x3c;@&#x26;${this.id}&#x3e;`;
    }

    /**
    * Edit the guild role
    * @arg {Object} options The properties to edit
    * @arg {String} [options.name] The name of the role
    * @arg {Number} [options.permissions] The role permissions number
    * @arg {Number} [options.color] The hex color of the role, in number form (ex: 0x3da5b3 or 4040115)
    * @arg {Boolean} [options.hoist] Whether to hoist the role in the user list or not
    * @arg {Boolean} [options.mentionable] Whether the role is mentionable or not
    * @returns {Promise&#x3c;Role&#x3e;}
    */
    edit(options) {
        return this.guild.shard.client.editRole.call(this.guild.shard.client, this.guild.id, this.id, options);
    }

    /**
    * Edit the role&#x27;s position. Note that role position numbers are highest on top and lowest at the bottom.
    * @arg {Number} position The new position of the role
    * @returns {Promise}
    */
    editPosition(position) {
        return this.guild.shard.client.editRolePosition.call(this.guild.shard.client, this.guild.id, this.id, position);
    }

    /**
    * Delete the role
    * @returns {Promise}
    */
    delete() {
        return this.guild.shard.client.deleteRole.call(this.guild.shard.client, this.guild.id, this.id);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Shard" id="apidoc.element.eris.Shard">
        function <span class="apidocSignatureSpan">eris.</span>Shard
        <span class="apidocSignatureSpan">(id, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Shard extends EventEmitter {
    constructor(id, client) {
        super();

        this.id = id;
        this.client = client;

        this.hardReset();
    }

    get latency() {
        return this.lastHeartbeatSent &#x26;&#x26; this.lastHeartbeatReceived ? this.lastHeartbeatReceived - this.lastHeartbeatSent : Infinity
;
    }

<span class="apidocCodeCommentSpan">    /**
    * Tells the shard to connect
    */
</span>    connect() {
        if(this.ws &#x26;&#x26; this.ws.readyState != WebSocket.CLOSED) {
            this.client.emit(&#x22;error&#x22;, new Error(&#x22;Existing connection detected&#x22;), this.id);
            return;
        }
        ++this.connectAttempts;
        this.connecting = true;
        return this.initializeWS();
    }

    /**
    * Disconnects the shard
    * @arg {Object?} [options] Shard disconnect options
    * @arg {String | Boolean} [options.reconnect] false means destroy everything, true means you want to reconnect in the future
, &#x22;auto&#x22; will autoreconnect
    */
    disconnect(options, error) {
        if(!this.ws) {
            return;
        }
        options = options || {};
        if(this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
        if(this.ws) {
            this.ws.onclose = undefined;
            try {
                if(options.reconnect &#x26;&#x26; this.sessionID) {
                    this.ws.terminate();
                } else {
                    this.ws.close();
                }
            } catch(err) {
                /**
                * Fired when the shard encounters an error
                * @event Client#error
                * @prop {Error} err The error
                * @prop {Number} id The ID of the shard
                */
                this.client.emit(&#x22;error&#x22;, err, this.id);
            }
            /**
            * Fired when the shard disconnects
            * @event Shard#disconnect
            * @prop {Error?} err The error, if any
            */
            this.emit(&#x22;disconnect&#x22;, error || null);
            this.ws = null;
        }
        this.status = &#x22;disconnected&#x22;;
        this.reset();
        if(options.reconnect === &#x22;auto&#x22; &#x26;&#x26; this.client.options.autoreconnect) {
            /**
            * Fired when stuff happens and gives more info
            * @event Client#debug
            * @prop {String} message The debug message
            * @prop {Number} id The ID of the shard
            */
            this.client.emit(&#x22;debug&#x22;, `Queueing reconnect in ${this.reconnectInterval}ms | Attempt ${this.connectAttempts}`, this
.id);
            setTimeout(() =&#x3e; {
                this.client.shards.connect(this);
            }, this.reconnectInterval);
            this.reconnectInterval = Math.min(Math.round(this.reconnectInterval * (Math.random() * 2 + 1)), 30000);
        } else if(!options.reconnect) {
            this.hardReset();
        }
    }

    reset() {
        this.connecting = false;
        this.ready = false;
        this.preReady = false;
        this.getAllUsersCount = {};
        this.getAllUsersQueue = [];
        this.getAllUsersLength = 1;
        this.guildSyncQueue = [];
        this.guildSyncQueueLength = 1;
        this.unsyncedGuilds = 0;
        this.lastHeartbeatAck = true;
        this.lastHeartbeatReceived = null;
        this.lastHeartbeatSent = null;
        this.status = &#x22;disconnected&#x22;;
    }

    hardReset() {
        this.reset();
        this.seq = 0;
        this.sessionID = null;
        this.reconnectInterval = 1000;
        this.connectAttempts = 0;
        this.ws = null;
        this.heartbeatInterval = null;
        this.guildCreateTimeout = null;
        this.idleSince = null;
        this.globalBucket = new Bucket(120, 60000, 0);
        this.presenceUpdateBucket = new Bucket(5, 60000, 0);
        this.presence = JSON.parse(JSON.stringify(this.client.presence)); // Fast copy
    }

    resume() {
        this.sendWS(OPCodes.RESUME, {
            token: this.client.token,
            session_id: this.sessionID,
            seq: this.seq
        }, true);
    }

    identify() {
        var ide ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.SharedStream" id="apidoc.element.eris.SharedStream">
        function <span class="apidocSignatureSpan">eris.</span>SharedStream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SharedStream extends EventEmitter {
    constructor() {
        super();

        this.samplingRate = 48000;
        this.frameDuration = 60;
        this.channels = 2;

        this.voiceConnections = new Collection(VoiceConnection);

        this.converterCommand = null;
        var pick = this.pickCommand();
        if(pick instanceof Error) {
            this.emit(&#x22;error&#x22;, pick);
        }

        if(NodeOpus) {
            this.opus = new NodeOpus.OpusEncoder(this.samplingRate, this.channels);
        } else if(OpusScript) {
            this.emit(&#x22;debug&#x22;, &#x22;node-opus not found, falling back to opusscript&#x22;);
            this.opus = new OpusScript(this.samplingRate, this.channels, OpusScript.Application.AUDIO);
            this.opus.setBitrate(this.bitrate);
        } else {
            this.emit(&#x22;warn&#x22;, new Error(&#x22;No opus encoder found, playing non-opus audio will not work.&#x22;));
        }

        this.piper = new Piper(this.converterCommand, this.opus);
        this.piper.on(&#x22;error&#x22;, (e) =&#x3e; this.emit(&#x22;error&#x22;, e));

        if(pick &#x26;&#x26; this.converterCommand) {
            this.piper.libopus = false;
        }

        this.speaking = false;

        this._send = this._send.bind(this);
    }

<span class="apidocCodeCommentSpan">    /**
    * Add a voice connection to the shared stream
    * @arg {VoiceConnection} connection The voice connection to add
    */
</span>    add(_connection) {
        var connection = this.voiceConnections.add(_connection);
        if(connection.ready) {
            connection.setSpeaking(this.speaking);
        } else {
            connection.once(&#x22;ready&#x22;, () =&#x3e; {
                connection.setSpeaking(this.speaking);
            });
        }
        return connection;
    }

    /**
    * Remove a voice connection from the shared stream
    * @arg {VoiceConnection} connection The voice connection to remove
    */
    remove(_connection) {
        return this.voiceConnections.remove(_connection);
    }

    /**
    * Play an audio or video resource. If playing from a non-opus resource, FFMPEG should be compiled with --enable-libopus for
best performance. If playing from HTTPS, FFMPEG must be compiled with --enable-openssl
    * @arg {ReadableStream | String} resource The audio or video resource, either a ReadableStream, URL, or file path
    * @arg {Object} [options] Music options
    * @arg {Boolean} [options.inlineVolume=false] Whether to enable on-the-fly volume changing. Note that enabling this leads to
 increased CPU usage
    * @arg {Number} [options.voiceDataTimeout=2000] Timeout when waiting for voice data (-1 for no timeout)
    * @arg {Array&#x3c;String&#x3e;} [options.inputArgs] Additional input parameters to pass to ffmpeg/avconv (before -i)
    * @arg {Array&#x3c;String&#x3e;} [options.encoderArgs] Additional encoder parameters to pass to ffmpeg/avconv (after -i)
    * @arg {String} [options.format] The format of the resource. If null, FFmpeg will attempt to guess and play the format. Available
 options: &#x22;dca&#x22;, &#x22;ogg&#x22;, &#x22;pcm&#x22;, null
    * @arg {Number} [options.frameDuration=60] The resource opus frame duration (required for DCA/Ogg)
    * @arg {Number} [options.frameSize=2880] The resource opus frame size
    * @arg {Number} [options.sampleRate=48000] The resource audio sampling rate
    */
    play(source, options) {
        options = options || {};
        options.format = options.format || null;
        options.voiceDataTimeout = !isNaN(options.voiceDataTimeout) ? options.voiceDataTimeout : 2000;
        options.inlineVolume = !!options.inlineVolume;
        options.inputArgs = options.inputArgs || [];
        options.encoderArgs = options.encoderArgs || [];

        options.samplingRate = options.samplingRate || this.samplingRate;
        options.frameDuration = options.frameDuration || this.frameDuration;
        options.frameSize = options.frameSize || options.samplingRate * options.frameDuration / 1000;
        options.pcmSize = options.pcmSize || options.frameSize * 2 * this.channels;

        if(!this.piper.encode(source, options)) {
            this.emit(&#x22;error&#x22;, new Error(&#x22;Unable to encode source&#x22;));
            return; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.User" id="apidoc.element.eris.User">
        function <span class="apidocSignatureSpan">eris.</span>User
        <span class="apidocSignatureSpan">(data, client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class User extends Base {
    constructor(data, client) {
        super(data.id);
        this._client = client;
        this.bot = !!data.bot;
        this.update(data);
    }

    update(data) {
        this.avatar = data.avatar !== undefined ? data.avatar : this.avatar;
        this.username = data.username !== undefined ? data.username : this.username;
        this.discriminator = data.discriminator !== undefined ? data.discriminator : this.discriminator;
    }

    get mention() {
        return `&#x3c;@${this.id}&#x3e;`;
    }

    get defaultAvatar() {
        return DefaultAvatarHashes[this.discriminator % DefaultAvatarHashes.length];
    }

    get defaultAvatarURL() {
        return `https://discordapp.com/assets/${this.defaultAvatar}.png`;
    }

    get staticAvatarURL(){
        return this.avatar ? `${CDN_URL}/avatars/${this.id}/${this.avatar}.${this._client.options.defaultImageFormat}?size=${this
._client.options.defaultImageSize}` : this.defaultAvatarURL;
    }

    get avatarURL() {
        return this.avatar ? `${CDN_URL}/avatars/${this.id}/${this.avatar}.${this.avatar.startsWith(&#x22;a_&#x22;) ? &#x22;gif&#x22; : this._client
.options.defaultImageFormat}?size=${this._client.options.defaultImageSize}` : this.defaultAvatarURL;
    }

<span class="apidocCodeCommentSpan">    /**
    * Get the user&#x27;s avatar with the given format and size
    * @arg {String} [format] The filetype of the avatar (&#x22;jpg&#x22;, &#x22;png&#x22;, &#x22;gif&#x22;, or &#x22;webp&#x22;)
    * @arg {Number} [size] The size of the avatar (128, 256, 512, 1024, 2048)
    */
</span>    dynamicAvatarURL(format, size) {
        if(format === undefined || !~Constants.ImageFormats.indexOf(format.toLowerCase())) {
            format = this.avatar.startsWith(&#x22;a_&#x22;) ? &#x22;gif&#x22; : this._client.options.defaultImageFormat;
        }
        if(size === undefined || !~Constants.ImageSizes.indexOf(size)) {
            size = this._client.options.defaultImageSize;
        }
        return this.avatar ? `${CDN_URL}/avatars/${this.id}/${this.avatar}.${format}?size=${size}` : this.defaultAvatarURL;
    }

    /**
    * Get a DM channel with the user, or create one if it does not exist
    * @returns {Promise&#x3c;PrivateChannel&#x3e;}
    */
    getDMChannel() {
        return this._client.getDMChannel.call(this._client, this.id);
    }

    /**
    * Create a relationship with the user
    * @arg {Boolean} [block=false] If true, block the user. Otherwise, add the user as a friend
    * @returns {Promise}
    */
    addRelationship(block) {
        return this._client.addRelationship.call(this._client, this.id, block);
    }

    /**
    * Remove a relationship with the user
    * @returns {Promise}
    */
    removeRelationship() {
        return this._client.removeRelationship.call(this._client, this.id);
    }

    /**
    * Get profile data for the user (user accounts only)
    * @returns {Promise&#x3c;Object&#x3e;} The user&#x27;s profile data.
    */
    getProfile() {
        return this._client.getUserProfile.call(this._client, this.id);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.VoiceConnection" id="apidoc.element.eris.VoiceConnection">
        function <span class="apidocSignatureSpan">eris.</span>VoiceConnection
        <span class="apidocSignatureSpan">(id, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class VoiceConnection extends EventEmitter {
    constructor(id, options) {
        super();
        options = options || {};

        if(typeof window !== &#x22;undefined&#x22;) {
            throw new Error(&#x22;Voice is not supported in browsers at this time&#x22;);
        }

        if(!Sodium &#x26;&#x26; !NaCl) {
            throw new Error(&#x22;Error loading tweetnacl/libsodium, voice not available&#x22;);
        }

        this.id = id;
        this.samplingRate = 48000;
        this.channels = 2;
        this.frameDuration = 20;
        this.frameSize = this.samplingRate * this.frameDuration / 1000;
        this.pcmSize = this.frameSize * this.channels * 2;
        this.bitrate = 64000;
        this.shared = !!options.shared;
        this.shard = options.shard || {};
        this.opusOnly = !!options.opusOnly;

        if(!this.opusOnly &#x26;&#x26; !this.shared) {
            if(NodeOpus) {
                this.opus = new NodeOpus.OpusEncoder(this.samplingRate, this.channels);
            } else if(OpusScript) {
                this.emit(&#x22;debug&#x22;, &#x22;node-opus not found, falling back to opusscript&#x22;);
                this.opus = new OpusScript(this.samplingRate, this.channels, OpusScript.Application.AUDIO);
                this.opus.setBitrate(this.bitrate);
            } else {
                throw new Error(&#x22;No opus encoder found, playing non-opus audio will not work.&#x22;);
            }
        }

        this.channelID = null;
        this.paused = true;
        this.speaking = false;
        this.sequence = 0;
        this.timestamp = 0;
        this.ssrcUserMap = {};
        this.converterCommand = null;

        this.nonce = new Buffer(24);
        this.nonce.fill(0);

        this.packetBuffer = new Buffer(12 + 16 + MAX_FRAME_SIZE);
        this.packetBuffer.fill(0);
        this.packetBuffer[0] = 0x80;
        this.packetBuffer[1] = 0x78;

        if(!options.shared) {
            var pick = this.pickCommand();
            if(pick instanceof Error) {
<span class="apidocCodeCommentSpan">                /**
                * Fired when the voice connection encounters an error. This event should be handled by users
                * @event VoiceConnection#error
                * @prop {Error} err The error object
                */
</span>                this.emit(&#x22;error&#x22;, pick);
            }

            this.piper = new Piper(this.converterCommand, this.opus);
            this.piper.on(&#x22;error&#x22;, (e) =&#x3e; this.emit(&#x22;error&#x22;, e));

            if(pick &#x26;&#x26; this.converterCommand) {
                this.piper.libopus = false;
            }
        }

        this._send = this._send.bind(this);
    }

    _destroy() {
        if(this.opus &#x26;&#x26; this.opus.delete) {
            this.opus.delete();
            delete this.opus;
        }
        delete this.piper;
        if(this.receiveStreamOpus) {
            this.receiveStreamOpus.destroy();
        }
        if(this.receiveStreamPCM) {
            this.receiveStreamPCM.destroy();
        }
    }

    connect(data) {
        if(this.ws &#x26;&#x26; this.ws.readyState !== WebSocket.CLOSED) {
            this.disconnect(undefined, true);
            return setTimeout(() =&#x3e; this.connect(data), 500);
        }
        if(!data.endpoint || !data.token || !data.session_id || !data.user_id) {
            this.disconnect(new Error(&#x22;Malformed voice server update: &#x22; + JSON.stringify(data)), false);
            return;
        }
        this.channelID = data.channel_id;
        this.endpoint = data.endpoint.split(&#x22;:&#x22;)[0];
        this.ws = new WebSocket(&#x22;wss://&#x22; + this.endpoint);
        /**
        * Fired when stuff happens and gives more info
        * @event VoiceConnection#debug
        * @prop {String} message The debug message
        */
        this.emit(&#x22;debug&#x22;, &#x22;Connecting to WS: wss://&#x22; + this.endpoint);
        this.ws.on(&#x22;open&#x22;, () =&#x3e; {
            /**
            * Fired when the voice connection connects
            * @event VoiceConnection#connect
            */
            this.emit(&#x22;connect&#x22;);
            this.sendWS(OPCodes.IDENTIFY, {
                server_id: this.id === &#x22;call&#x22; ? data.channel_id : this.id,
                user_id: data.user_id, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.VoiceConnectionManager" id="apidoc.element.eris.VoiceConnectionManager">
        function <span class="apidocSignatureSpan">eris.</span>VoiceConnectionManager
        <span class="apidocSignatureSpan">(vcObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class VoiceConnectionManager extends Collection {
    constructor(vcObject) {
        super(vcObject || require(&#x22;./VoiceConnection&#x22;));
        this.pendingGuilds = {};
    }

    join(guildID, channelID, options) {
        var connection = this.get(guildID);
        if(connection) {
            connection.switchChannel(channelID);
            return Promise.resolve(connection);
        }
        return new Promise((res, rej) =&#x3e; {
            this.pendingGuilds[guildID] = {
                channelID: channelID,
                options: options || {},
                res: res,
                rej: rej,
                timeout: setTimeout(() =&#x3e; {
                    delete this.pendingGuilds[guildID];
                    rej(new Error(&#x22;Voice connection timeout&#x22;));
                }, 10000)
            };
        });
    }

    voiceServerUpdate(data) {
        if(this.pendingGuilds[data.guild_id] &#x26;&#x26; this.pendingGuilds[data.guild_id].timeout) {
            clearTimeout(this.pendingGuilds[data.guild_id].timeout);
            this.pendingGuilds[data.guild_id].timeout = null;
        }
        var connection = this.get(data.guild_id);
        if(!connection) {
            if(!this.pendingGuilds[data.guild_id]) {
                return;
            }
            connection = this.add(new this.baseObject(data.guild_id, {
                shard: data.shard,
                opusOnly: this.pendingGuilds[data.guild_id].options.opusOnly,
                shared: this.pendingGuilds[data.guild_id].options.shared
            }));
        }
        connection.connect({
            channel_id: (this.pendingGuilds[data.guild_id] || connection).channelID,
            endpoint: data.endpoint,
            token: data.token,
            session_id: data.session_id,
            user_id: data.user_id
        });
        if(!this.pendingGuilds[data.guild_id] || this.pendingGuilds[data.guild_id].waiting) {
            return;
        }
        this.pendingGuilds[data.guild_id].waiting = true;
        var disconnectHandler = () =&#x3e; {
            connection = this.get(data.guild_id);
            if(!this.pendingGuilds[data.guild_id]) {
                if(connection) {
                    connection.removeListener(&#x22;ready&#x22;, readyHandler);
                }
                return;
            }
            this.pendingGuilds[data.guild_id].rej(new Error(&#x22;Disconnected&#x22;));
            delete this.pendingGuilds[data.guild_id];
            connection.removeListener(&#x22;ready&#x22;, readyHandler);
        };
        var readyHandler = () =&#x3e; {
            connection = this.get(data.guild_id);
            if(!this.pendingGuilds[data.guild_id]) {
                if(connection) {
                    connection.removeListener(&#x22;disconnect&#x22;, disconnectHandler);
                }
                return;
            }
            this.pendingGuilds[data.guild_id].res(connection);
            delete this.pendingGuilds[data.guild_id];
            connection.removeListener(&#x22;disconnect&#x22;, disconnectHandler);
        };
        connection.once(&#x22;ready&#x22;, readyHandler).once(&#x22;disconnect&#x22;, disconnectHandler);
    }

    leave(guildID) {
        var connection = this.get(guildID);
        if(!connection) {
            return;
        }
        connection.disconnect();
        connection._destroy();
        this.remove(connection);
    }

    switch(guildID, channelID) {
        var connection = this.get(guildID);
        if(!connection) {
            return;
        }
        connection.switch(channelID);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.VoiceState" id="apidoc.element.eris.VoiceState">
        function <span class="apidocSignatureSpan">eris.</span>VoiceState
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class VoiceState extends Base {
    constructor(data) {
        super(data.id);
        this.update(data);
    }

    update(data) {
        if(data.channel_id !== undefined) {
            this.channelID = data.channel_id;
            this.sessionID = data.channel_id === null ? null : data.session_id;
        } else if(this.channelID === undefined) {
            this.channelID = this.sessionID = null;
        }
        this.mute = data.mute !== undefined ? data.mute : this.mute || false;
        this.deaf = data.deaf !== undefined ? data.deaf : this.deaf || false;
        this.suppress = data.suppress !== undefined ? data.suppress : this.suppress || false; // Bots ignore this
        this.selfMute = data.self_mute !== undefined ? data.self_mute : this.selfMute || false;
        this.selfDeaf = data.self_deaf !== undefined ? data.self_deaf : this.selfDeaf || false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eris.Endpoints" id="apidoc.module.eris.Endpoints">module eris.Endpoints</a></h1>


    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL" id="apidoc.element.eris.Endpoints.CHANNEL">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    */
    editChannel(channelID, options) {
var channel = this.getChannel(channelID);
if(!channel) {
    return Promise.reject(new Error(`Channel ${channelID} not found`));
}

return this.requestHandler.request(&#x22;PATCH&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL</span>(channelID), true
, {
    name: options.name,
    icon: options.icon,
    owner_id: options.ownerID,
    topic: options.topic,
    bitrate: options.bitrate,
    user_limit: options.userLimit
}).then((data) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_BULK_DELETE" id="apidoc.element.eris.Endpoints.CHANNEL_BULK_DELETE">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_BULK_DELETE
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}/messages/bulk_delete`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var oldestAllowedSnowflake = (Date.now() - 1421280000000) * 4194304;
    var invalidMessage = messageIDs.find((messageID) =&#x3e; messageID &#x3c; oldestAllowedSnowflake);
    if(invalidMessage) {
        return Promise.reject(new Error(`Message ${invalidMessage} is more than 2 weeks old.`));
    }

    if(messageIDs.length &#x3e; 100) {
        return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_BULK_DELETE</
span>(channelID), true, {
            messages: messageIDs.splice(0, 100)
        }).then(() =&#x3e; this.deleteMessages(channelID, messageIDs));
    }
    return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.CHANNEL_BULK_DELETE(channelID), true, {
        messages: messageIDs
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_CALL_RING" id="apidoc.element.eris.Endpoints.CHANNEL_CALL_RING">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_CALL_RING
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}/call/ring`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
* Ring fellow group channel recipient(s)
* @arg {String[]} recipients The IDs of the recipients to ring
*/
ring(recipients) {
    this._client.requestHandler.request(&#x22;POST&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_CALL_RING</span>(
this.id), true, {
        recipients
    });
}

/**
* Check if the channel has an existing call
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_INVITES" id="apidoc.element.eris.Endpoints.CHANNEL_INVITES">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_INVITES
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}/invites`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get all invites in a channel
* @arg {String} channelID The ID of the channel
* @returns {Promise&#x3c;Invite[]&#x3e;}
*/
getChannelInvites(channelID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_INVITES</span>(channelID
), true).then((invites) =&#x3e; invites.map((invite) =&#x3e; new Invite(invite, this)));
}

/**
* Create an invite for a channel
* @arg {String} channelID The ID of the channel
* @arg {Object} [options] Invite generation options
* @arg {Number} [options.maxAge] How long the invite should last in seconds
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGE" id="apidoc.element.eris.Endpoints.CHANNEL_MESSAGE">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGE
        <span class="apidocSignatureSpan">(chanID, msgID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID, msgID) =&#x3e; `/channels/${chanID}/messages/${msgID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Get a previous message in a channel
* @arg {String} channelID The ID of the channel
* @arg {String} messageID The ID of the message
* @returns {Promise&#x3c;Message&#x3e;}
*/
getMessage(channelID, messageID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_MESSAGE</span>(channelID
, messageID), true).then((message) =&#x3e; new Message(message, this));
}

/**
* Get previous messages in a channel
* @arg {String} channelID The ID of the channel
* @arg {Number} [limit=50] The max number of messages to get
* @arg {String} [before] Get messages before this message ID
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGES" id="apidoc.element.eris.Endpoints.CHANNEL_MESSAGES">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGES
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}/messages`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @returns {Promise&#x3c;Message[]&#x3e;}
*/
getMessages(channelID, limit, before, after, around) {
    if(limit &#x26;&#x26; limit &#x3e; 100) {
        return new Promise((resolve, reject) =&#x3e; {
            var logs = [];
            var get = (_before, _after) =&#x3e; {
                this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_MESSAGES</span
>(channelID), true, {
                    limit: 100,
                    before: _before || undefined,
                    after: _after || undefined
                }).then((messages) =&#x3e; {
                    if(limit &#x3c;= messages.length) {
                        return resolve((_after ? messages.slice(messages.length - limit, messages.length).map((message) =&#x3e;
new Message(message, this)).concat(logs) : logs.concat(messages.slice(0, limit).map((message) =&#x3e; new Message(message, this)))));
                    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGES_SEARCH" id="apidoc.element.eris.Endpoints.CHANNEL_MESSAGES_SEARCH">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGES_SEARCH
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}/messages/search`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         [Message, Message, Message (Message.hit = true), Message],
*         [Message, Message, Message (Message.hit = true), Message, Message]
*     ]
* }
* ```
*/
searchChannelMessages(channelID, query) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_MESSAGES_SEARCH</span
>(channelID), true, {
        sort_by: query.sortBy,
        sort_order: query.sortOrder,
        content: query.content,
        author_id: query.authorID,
        min_id: query.minID,
        max_id: query.maxID,
        limit: query.limit,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGE_REACTION" id="apidoc.element.eris.Endpoints.CHANNEL_MESSAGE_REACTION">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGE_REACTION
        <span class="apidocSignatureSpan">(chanID, msgID, reaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID, msgID, reaction) =&#x3e; `/channels/${chanID}/messages/${msgID}/reactions/${reaction}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {Number} [limit=100] The maximum number of users to get
* @returns {Promise&#x3c;User[]&#x3e;}
*/
getMessageReaction(channelID, messageID, reaction, limit) {
    if(reaction === decodeURI(reaction)) {
        reaction = encodeURIComponent(reaction);
    }
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_MESSAGE_REACTION</
span>(channelID, messageID, reaction), true, {
        limit: limit || 100
    }).then((users) =&#x3e; users.map((user) =&#x3e; new User(user, this)));
}

/**
* Add a reaction to a message
* @arg {String} channelID The ID of the channel
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGE_REACTIONS" id="apidoc.element.eris.Endpoints.CHANNEL_MESSAGE_REACTIONS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGE_REACTIONS
        <span class="apidocSignatureSpan">(chanID, msgID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID, msgID) =&#x3e; `/channels/${chanID}/messages/${msgID}/reactions`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Remove all reactions from a message
* @arg {String} channelID The ID of the channel
* @arg {String} messageID The ID of the message
* @returns {Promise}
*/
removeMessageReactions(channelID, messageID) {
    return this.requestHandler.request(&#x22;DELETE&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_MESSAGE_REACTIONS
</span>(channelID, messageID), true);
}

/**
* Delete a message
* @arg {String} channelID The ID of the channel
* @arg {String} messageID The ID of the message
* @returns {Promise}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_MESSAGE_REACTION_USER" id="apidoc.element.eris.Endpoints.CHANNEL_MESSAGE_REACTION_USER">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_MESSAGE_REACTION_USER
        <span class="apidocSignatureSpan">(chanID, msgID, reaction, userID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID, msgID, reaction, userID) =&#x3e; `/channels/${chanID}/messages/${msgID}/reactions/${reaction}/${userID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {String} [userID=&#x22;@me&#x22;] The ID of the user to react as
* @returns {Promise}
*/
addMessageReaction(channelID, messageID, reaction, userID) {
    if(reaction === decodeURI(reaction)) {
        reaction = encodeURIComponent(reaction);
    }
    return this.requestHandler.request(&#x22;PUT&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_MESSAGE_REACTION_USER
</span>(channelID, messageID, reaction, userID || &#x22;@me&#x22;), true);
}

/**
* Remove a reaction from a message
* @arg {String} channelID The ID of the channel
* @arg {String} messageID The ID of the message
* @arg {String} reaction The reaction (Unicode string if Unicode emoji, `emojiName:emojiID` if custom emoji)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_PERMISSION" id="apidoc.element.eris.Endpoints.CHANNEL_PERMISSION">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_PERMISSION
        <span class="apidocSignatureSpan">(chanID, overID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID, overID) =&#x3e; `/channels/${chanID}/permissions/${overID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {String} overwriteID The ID of the overwritten user or role
* @arg {Number} allow The permissions number for allowed permissions
* @arg {Number} deny The permissions number for denied permissions
* @arg {String} type The object type of the overwrite, either &#x22;member&#x22; or &#x22;role&#x22;
* @returns {Promise}
*/
editChannelPermission(channelID, overwriteID, allow, deny, type) {
    return this.requestHandler.request(&#x22;PUT&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_PERMISSION</span>(
channelID, overwriteID), true, {
        allow,
        deny,
        type
    });
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_PERMISSIONS" id="apidoc.element.eris.Endpoints.CHANNEL_PERMISSIONS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_PERMISSIONS
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}/permissions`</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_PIN" id="apidoc.element.eris.Endpoints.CHANNEL_PIN">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_PIN
        <span class="apidocSignatureSpan">(chanID, msgID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID, msgID) =&#x3e; `/channels/${chanID}/pins/${msgID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Pin a message
* @arg {String} channelID The ID of the channel
* @arg {String} messageID The ID of the message
* @returns {Promise}
*/
pinMessage(channelID, messageID) {
    return this.requestHandler.request(&#x22;PUT&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_PIN</span>(channelID
, messageID), true);
}

/**
* Unpin a message
* @arg {String} channelID The ID of the channel
* @arg {String} messageID The ID of the message
* @returns {Promise}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_PINS" id="apidoc.element.eris.Endpoints.CHANNEL_PINS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_PINS
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}/pins`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get all the pins in a channel
* @arg {String} channelID The ID of the channel
* @returns {Promise&#x3c;Message[]&#x3e;}
*/
getPins(channelID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_PINS</span>(channelID
), true).then((messages) =&#x3e; messages.map((message) =&#x3e; new Message(message, this)));
}

/**
* Create a message in a channel
* Note: If you want to DM someone, the user ID is **not** the DM channel ID. use Client.getDMChannel() to get the DM channel for
 a user
* @arg {String} channelID The ID of the channel
* @arg {String | Array | Object} content A string, array of strings, or object. If an object is passed:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_RECIPIENT" id="apidoc.element.eris.Endpoints.CHANNEL_RECIPIENT">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_RECIPIENT
        <span class="apidocSignatureSpan">(groupID, userID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(groupID, userID) =&#x3e; `/channels/${groupID}/recipients/${userID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Add a user to a group
* @arg {String} groupID The ID of the target group
* @arg {String} userID The ID of the target user
* @returns {Promise}
*/
addGroupRecipient(groupID, userID) {
    return this.requestHandler.request(&#x22;PUT&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_RECIPIENT</span>(groupID
, userID), true);
}

/**
* Remove a user from a group
* @arg {String} groupID The ID of the target group
* @arg {String} userID The ID of the target user
* @returns {Promise}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_TYPING" id="apidoc.element.eris.Endpoints.CHANNEL_TYPING">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_TYPING
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}/typing`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Send typing status in a channel
* @arg {String} channelID The ID of the channel
* @returns {Promise}
*/
sendChannelTyping(channelID) {
    return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_TYPING</span>(channelID
), true);
}

/**
* Create a channel permission overwrite
* @arg {String} channelID The ID of channel
* @arg {String} overwriteID The ID of the overwritten user or role
* @arg {Number} allow The permissions number for allowed permissions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.CHANNEL_WEBHOOKS" id="apidoc.element.eris.Endpoints.CHANNEL_WEBHOOKS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>CHANNEL_WEBHOOKS
        <span class="apidocSignatureSpan">(chanID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(chanID) =&#x3e; `/channels/${chanID}/webhooks`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get all the webhooks in a channel
* @arg {String} channelID The ID of the channel to get webhooks for
* @returns {Promise&#x3c;Object[]&#x3e;} Resolves with an array of webhook objects
*/
getChannelWebhooks(channelID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">CHANNEL_WEBHOOKS</span>(channelID
), true);
}

/**
* Get a webhook
* @arg {String} webhookID The ID of the webhook
* @arg {String} [token] The token of the webhook, used instead of the Bot Authorization token
* @returns {Promise&#x3c;Object&#x3e;} Resolves with a webhook object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD" id="apidoc.element.eris.Endpoints.GUILD">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {String} [options.afkChannelID] The ID of the AFK voice channel
* @arg {Number} [options.afkTimeout] The AFK timeout in seconds
* @arg {String} [options.ownerID] The ID of the user to transfer server ownership to (bot user must be owner)
* @arg {String} [options.splash] The guild splash image as a base64 data URI (VIP only). Note: base64 strings alone are not base64
 data URI strings
* @returns {Promise&#x3c;Guild&#x3e;}
*/
editGuild(guildID, options) {
    return this.requestHandler.request(&#x22;PATCH&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD</span>(guildID), true
, {
        name: options.name,
        region: options.region,
        icon: options.icon,
        verification_level: options.verificationLevel,
        default_message_notifications: options.defaultNotifications,
        afk_channel_id: options.afkChannelID,
        afk_timeout: options.afkTimeout,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_BAN" id="apidoc.element.eris.Endpoints.GUILD_BAN">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_BAN
        <span class="apidocSignatureSpan">(guildID, memberID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID, memberID) =&#x3e; `/guilds/${guildID}/bans/${memberID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {Number} [deleteMessageDays=0] Number of days to delete messages for, between 0-7 inclusive
* @returns {Promise}
*/
banGuildMember(guildID, userID, deleteMessageDays) {
    if(!isNaN(deleteMessageDays) &#x26;&#x26; (deleteMessageDays &#x3c; 0 || deleteMessageDays &#x3e; 7)) {
        return Promise.reject(new Error(`Invalid deleteMessageDays value (${deleteMessageDays}), should be a number between 0-7
inclusive`));
    }
    return this.requestHandler.request(&#x22;PUT&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_BAN</span>(guildID,
userID), true, {
        &#x22;delete-message-days&#x22;: deleteMessageDays || 0
    });
}

/**
* Unban a user from a guild
* @arg {String} guildID The ID of the guild
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_BANS" id="apidoc.element.eris.Endpoints.GUILD_BANS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_BANS
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/bans`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get the ban list of a guild
* @arg {String} guildID The ID of the guild
* @returns {Promise&#x3c;User[]&#x3e;}
*/
getGuildBans(guildID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_BANS</span>(guildID),
true).then((bans) =&#x3e; bans.map((ban) =&#x3e; new User(ban.user, this)));
}

/**
* Edit a guild member
* @arg {String} guildID The ID of the guild
* @arg {String} memberID The ID of the member
* @arg {Object} options The properties to edit
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_CHANNELS" id="apidoc.element.eris.Endpoints.GUILD_CHANNELS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_CHANNELS
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/channels`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @returns {Promise&#x3c;GuildChannel&#x3e;}
*/
createChannel(guildID, name, type) {
    var guild = this.guilds.get(guildID);
    if(!guild) {
        return Promise.reject(new Error(`Guild ${guildID} not found`));
    }
    return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_CHANNELS</span>(guildID
), true, {
        name,
        type
    }).then((channel) =&#x3e; new GuildChannel(channel, guild));
}

/**
* Edit a channel&#x27;s properties
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_EMBED" id="apidoc.element.eris.Endpoints.GUILD_EMBED">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_EMBED
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/embed`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get a guild&#x27;s embed object
* @arg {String} guildID The ID of the guild
* @returns {Promise&#x3c;Object&#x3e;} A guild embed object
*/
getGuildEmbed(guildID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_EMBED</span>(guildID
), true);
}

/**
* Get a list of integrations for a guild
* @arg {String} guildID The ID of the guild
* @returns {Promise&#x3c;GuildIntegration[]&#x3e;}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_EMOJI" id="apidoc.element.eris.Endpoints.GUILD_EMOJI">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_EMOJI
        <span class="apidocSignatureSpan">(guildID, emojiID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID, emojiID) =&#x3e; `/guilds/${guildID}/emojis/${emojiID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {String} emojiID The ID of the emoji you want to modify
* @arg {Object} options Emoji options
* @arg {String} [options.name] The name of emoji
* @arg {Array} [options.roles] An array containing authorized role IDs
* @returns {Promise&#x3c;Object&#x3e;} A guild emoji object
*/
editGuildEmoji(guildID, emojiID, options) {
  return this.requestHandler.request(&#x22;PATCH&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_EMOJI</span>(guildID
, emojiID), true, options);
}
/**
* Delete a guild emoji object (not for bot accounts)
* @arg {String} guildID The ID of the guild to delete the emoji in
* @arg {String} emojiID The ID of the emoji
* @returns {Promise}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_EMOJIS" id="apidoc.element.eris.Endpoints.GUILD_EMOJIS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_EMOJIS
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/emojis`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {Object} options Emoji options
* @arg {String} options.name The name of emoji
* @arg {String} options.image The base 64 encoded string
* @arg {Array} [options.roles] An array containing authorized role IDs
* @returns {Promise&#x3c;Object&#x3e;} A guild emoji object
*/
createGuildEmoji(guildID, options) {
  return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_EMOJIS</span>(guildID
), true, options);
}
/**
* Edit a guild emoji object (not for bot accounts)
* @arg {String} guildID The ID of the guild to edit the emoji in
* @arg {String} emojiID The ID of the emoji you want to modify
* @arg {Object} options Emoji options
* @arg {String} [options.name] The name of emoji
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_INTEGRATION" id="apidoc.element.eris.Endpoints.GUILD_INTEGRATION">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_INTEGRATION
        <span class="apidocSignatureSpan">(guildID, inteID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID, inteID) =&#x3e; `/guilds/${guildID}/integrations/${inteID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {Object} options The properties to edit
* @arg {String} [options.expireBehavior] What to do when a user&#x27;s subscription runs out
* @arg {String} [options.expireGracePeriod] How long before the integration&#x27;s role is removed from an unsubscribed user
* @arg {String} [options.enableEmoticons] Whether to enable integration emoticons or not
* @returns {Promise}
*/
editGuildIntegration(guildID, integrationID, options) {
    return this.requestHandler.request(&#x22;PATCH&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_INTEGRATION</span>(
guildID, integrationID), true, {
        expire_behavior: options.expireBehavior,
        expire_grace_period: options.expireGracePeriod,
        enable_emoticons: options.enableEmoticons
    });
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_INTEGRATIONS" id="apidoc.element.eris.Endpoints.GUILD_INTEGRATIONS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_INTEGRATIONS
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/integrations`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Get a list of integrations for a guild
* @arg {String} guildID The ID of the guild
* @returns {Promise&#x3c;GuildIntegration[]&#x3e;}
*/
getGuildIntegrations(guildID) {
    var guild = this.guilds.get(guildID);
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_INTEGRATIONS</span>(
guildID), true).then((integrations) =&#x3e; integrations.map((integration) =&#x3e; new GuildIntegration(integration, guild)));
}

/**
* Edit a guild integration
* @arg {String} guildID The ID of the guild
* @arg {String} integrationID The ID of the integration
* @arg {Object} options The properties to edit
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_INTEGRATION_SYNC" id="apidoc.element.eris.Endpoints.GUILD_INTEGRATION_SYNC">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_INTEGRATION_SYNC
        <span class="apidocSignatureSpan">(guildID, inteID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID, inteID) =&#x3e; `/guilds/${guildID}/integrations/${inteID}/sync`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Force a guild integration to sync
* @arg {String} guildID The ID of the guild
* @arg {String} integrationID The ID of the integration
* @returns {Promise}
*/
syncGuildIntegration(guildID, integrationID) {
    return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_INTEGRATION_SYNC</span
>(guildID, integrationID), true);
}

/**
* Get all invites in a guild
* @arg {String} guildID The ID of the guild
* @returns {Promise&#x3c;Invite[]&#x3e;}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_INVITES" id="apidoc.element.eris.Endpoints.GUILD_INVITES">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_INVITES
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/invites`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get all invites in a guild
* @arg {String} guildID The ID of the guild
* @returns {Promise&#x3c;Invite[]&#x3e;}
*/
getGuildInvites(guildID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_INVITES</span>(guildID
), true).then((invites) =&#x3e; invites.map((invite) =&#x3e; new Invite(invite, this)));
}

/**
* Ban a user from a guild
* @arg {String} guildID The ID of the guild
* @arg {String} userID The ID of the user
* @arg {Number} [deleteMessageDays=0] Number of days to delete messages for, between 0-7 inclusive
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_MEMBER" id="apidoc.element.eris.Endpoints.GUILD_MEMBER">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MEMBER
        <span class="apidocSignatureSpan">(guildID, memberID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID, memberID) =&#x3e; `/guilds/${guildID}/members/${memberID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {String} [options.nick] Set the member&#x27;s server nickname, &#x22;&#x22; to remove
* @arg {Boolean} [options.mute] Server mute the member
* @arg {Boolean} [options.deaf] Server deafen the member
* @arg {String} [options.channelID] The ID of the voice channel to move the member to (must be in voice)
* @returns {Promise}
*/
editGuildMember(guildID, memberID, options) {
    return this.requestHandler.request(&#x22;PATCH&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_MEMBER</span>(guildID
, memberID), true, {
        roles: options.roles,
        nick: options.nick,
        mute: options.mute,
        deaf: options.deaf,
        channel_id: options.channelID
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_MEMBERS" id="apidoc.element.eris.Endpoints.GUILD_MEMBERS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MEMBERS
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/members`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {String} [after] The highest user ID of the previous page
* @returns {Promise&#x3c;Member[]&#x3e;}
*/
getRESTGuildMembers(guildID, limit, after) {
    if(!this.options.restMode) {
        return Promise.reject(new Error(&#x22;Eris REST mode is not enabled&#x22;));
    }
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_MEMBERS</span>(guildID
), true, {
        limit,
        after
    }).then((members) =&#x3e; members.map((member) =&#x3e; new Member(member, null)));
}

/**
* Get a guild&#x27;s members via the REST API. REST mode is required to use this endpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_MEMBER_NICK" id="apidoc.element.eris.Endpoints.GUILD_MEMBER_NICK">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MEMBER_NICK
        <span class="apidocSignatureSpan">(guildID, memberID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID, memberID) =&#x3e; `/guilds/${guildID}/members/${memberID}/nick`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Edit the bot&#x27;s nickname in a guild
* @arg {String} guildID The ID of the guild
* @arg {String} nick The nickname
* @returns {Promise}
*/
editNickname(guildID, nick) {
    return this.requestHandler.request(&#x22;PATCH&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_MEMBER_NICK</span>(
guildID, &#x22;@me&#x22;), true, {
        nick
    });
}

/**
* Kick a user from a guild
* @arg {String} guildID The ID of the guild
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_MEMBER_ROLE" id="apidoc.element.eris.Endpoints.GUILD_MEMBER_ROLE">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MEMBER_ROLE
        <span class="apidocSignatureSpan">(guildID, memberID, roleID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID, memberID, roleID) =&#x3e; `/guilds/${guildID}/members/${memberID}/roles/${roleID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Add a role to a guild member
* @arg {String} guildID The ID of the guild
* @arg {String} memberID The ID of the member
* @arg {String} roleID The ID of the role
* @returns {Promise}
*/
addGuildMemberRole(guildID, memberID, roleID) {
    return this.requestHandler.request(&#x22;PUT&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_MEMBER_ROLE</span>(guildID
, memberID, roleID), true);
}

/**
* Remve a role from a guild member
* @arg {String} guildID The ID of the guild
* @arg {String} memberID The ID of the member
* @arg {String} roleID The ID of the role
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_MESSAGES_SEARCH" id="apidoc.element.eris.Endpoints.GUILD_MESSAGES_SEARCH">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_MESSAGES_SEARCH
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/messages/search`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         [Message, Message, Message (Message.hit = true), Message],
*         [Message, Message, Message (Message.hit = true), Message, Message]
*     ]
* }
* ```
*/
searchGuildMessages(guildID, query) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_MESSAGES_SEARCH</span
>(guildID), true, {
        sort_by: query.sortBy,
        sort_order: query.sortOrder,
        content: query.content,
        author_id: query.authorID,
        min_id: query.minID,
        max_id: query.maxID,
        limit: query.limit,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_PRUNE" id="apidoc.element.eris.Endpoints.GUILD_PRUNE">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_PRUNE
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/prune`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Get the prune count for a guild
* @arg {String} guildID The ID of the guild
* @arg {Number} days The number of days of inactivity to prune for
* @returns {Promise&#x3c;Number&#x3e;} Resolves with the number of users that would be pruned
*/
getPruneCount(guildID, days) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_PRUNE</span>(guildID
), true, {
        days
    }).then((data) =&#x3e; data.pruned);
}

/**
* Begin pruning a guild
* @arg {String} guildID The ID of the guild
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_ROLE" id="apidoc.element.eris.Endpoints.GUILD_ROLE">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_ROLE
        <span class="apidocSignatureSpan">(guildID, roleID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID, roleID) =&#x3e; `/guilds/${guildID}/roles/${roleID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {Number} [options.permissions] The role permissions number
* @arg {Number} [options.color] The hex color of the role, in number form (ex: 0x3da5b3 or 4040115)
* @arg {Boolean} [options.hoist] Whether to hoist the role in the user list or not
* @arg {Boolean} [options.mentionable] Whether the role is mentionable or not
* @returns {Promise&#x3c;Role&#x3e;}
*/
editRole(guildID, roleID, options) {
    return this.requestHandler.request(&#x22;PATCH&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_ROLE</span>(guildID
, roleID), true, options).then((role) =&#x3e; new Role(role, this.guilds.get(guildID)));
}

/**
* Edit a guild role&#x27;s position. Note that role position numbers are highest on top and lowest at the bottom.
* @arg {String} guildID The ID of the guild the role is in
* @arg {String} roleID The ID of the role
* @arg {Number} position The new position of the role
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_ROLES" id="apidoc.element.eris.Endpoints.GUILD_ROLES">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_ROLES
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/roles`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {Number} [options.permissions] The role permissions number
* @arg {Number} [options.color] The hex color of the role, in number form (ex: 0x3d15b3 or 4040115)
* @arg {Boolean} [options.hoist] Whether to hoist the role in the user list or not
* @arg {Boolean} [options.mentionable] Whether the role is mentionable or not
* @returns {Promise&#x3c;Role&#x3e;}
*/
createRole(guildID, options) {
    return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_ROLES</span>(guildID
), true, options).then((role) =&#x3e; new Role(role, this.guilds.get(guildID)));
}

/**
* Edit a guild role
* @arg {String} guildID The ID of the guild the role is in
* @arg {String} roleID The ID of the role
* @arg {Object} options The properties to edit
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_VOICE_REGIONS" id="apidoc.element.eris.Endpoints.GUILD_VOICE_REGIONS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_VOICE_REGIONS
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/regions`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get a list of general/guild-specific voice reigons
* @arg {String} [guildID] The ID of the guild
* @returns {Promise&#x3c;Object[]&#x3e;} Resolves with an array of voice region objects
*/
getVoiceRegions(guildID) {
    return guildID ? this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_VOICE_REGIONS
</span>(guildID), true) : this.requestHandler.request(&#x22;GET&#x22;, Endpoints.VOICE_REGIONS, true); // TODO parse regions
}

/**
* Get info on an invite
* @arg {String} inviteID The ID of the invite
* @returns {Promise&#x3c;Invite&#x3e;}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.GUILD_WEBHOOKS" id="apidoc.element.eris.Endpoints.GUILD_WEBHOOKS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>GUILD_WEBHOOKS
        <span class="apidocSignatureSpan">(guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(guildID) =&#x3e; `/guilds/${guildID}/webhooks`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get all the webhooks in a guild
* @arg {String} guildID The ID of the guild to get webhooks for
* @returns {Promise&#x3c;Object[]&#x3e;} Resolves with an array of webhook objects
*/
getGuildWebhooks(guildID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">GUILD_WEBHOOKS</span>(guildID
), true);
}

/**
* Create a guild emoji object (not for bot accounts)
* @arg {String} guildID The ID of the guild to create the emoji in
* @arg {Object} options Emoji options
* @arg {String} options.name The name of emoji
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.INVITE" id="apidoc.element.eris.Endpoints.INVITE">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>INVITE
        <span class="apidocSignatureSpan">(inviteID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(inviteID) =&#x3e; `/invite/${inviteID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get info on an invite
* @arg {String} inviteID The ID of the invite
* @returns {Promise&#x3c;Invite&#x3e;}
*/
getInvite(inviteID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">INVITE</span>(inviteID), true
).then((invite) =&#x3e; {
        if(this.channelGuildMap[invite.channel.id] &#x26;&#x26; this.getChannel(invite.channel.id).permissionsOf(this.user.id).json
.manageChannels) {
            return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.CHANNEL_INVITES(invite.channel.id), true, {
                validate: inviteID
            }).then((extendedInvite) =&#x3e; new Invite(extendedInvite, this));
        }
        return new Invite(invite, this);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.OAUTH2_APPLICATION" id="apidoc.element.eris.Endpoints.OAUTH2_APPLICATION">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>OAUTH2_APPLICATION
        <span class="apidocSignatureSpan">(appID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(appID) =&#x3e; `/oauth2/applications/${appID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get data on an OAuth2 application
* @arg {String} [appID=&#x22;@me&#x22;] The client ID of the application to get data for. &#x22;@me&#x22; refers to the logged in
 user&#x27;s own application
* @returns {Promise&#x3c;Object&#x3e;} The bot&#x27;s application data. Refer to [the official Discord API documentation entry](
https://discordapp.com/developers/docs/topics/oauth2#get-current-application-information) for object structure
*/
getOAuthApplication(appID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">OAUTH2_APPLICATION</span>(
appID || &#x22;@me&#x22;), true);
}

/**
* Get user settings (user accounts only)
* @returns {Promise&#x3c;Object&#x3e;} The user&#x27;s settings data.
*/
getUserSettings() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.USER" id="apidoc.element.eris.Endpoints.USER">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER
        <span class="apidocSignatureSpan">(userID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(userID) =&#x3e; `/users/${userID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
* Get properties of the bot user
* @returns {Promise&#x3c;ExtendedUser&#x3e;}
*/
getSelf() {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">USER</span>(&#x22;@me&#x22
;), true).then((data) =&#x3e; new ExtendedUser(data, this));
}

/**
* Edit properties of the bot user
* @arg {Object} options The properties to edit
* @arg {String} [options.username] The new username
* @arg {String} [options.avatar] The new avatar as a base64 data URI. Note: base64 strings alone are not base64 data URI strings
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.USER_CHANNELS" id="apidoc.element.eris.Endpoints.USER_CHANNELS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_CHANNELS
        <span class="apidocSignatureSpan">(userID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(userID) =&#x3e; `/users/${userID}/channels`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {String} userID The ID of the user
* @returns {Promise&#x3c;PrivateChannel&#x3e;}
*/
getDMChannel(userID) {
    if(this.privateChannelMap[userID]) {
        return Promise.resolve(this.privateChannels.get(this.privateChannelMap[userID]));
    }
    return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">USER_CHANNELS</span>(&#x22
;@me&#x22;), true, {
        recipients: [userID],
        type: 1
    }).then((privateChannel) =&#x3e; new PrivateChannel(privateChannel, this));
}

/**
* Create a group channel with other users
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.USER_GUILD" id="apidoc.element.eris.Endpoints.USER_GUILD">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_GUILD
        <span class="apidocSignatureSpan">(userID, guildID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(userID, guildID) =&#x3e; `/users/${userID}/guilds/${guildID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Leave a guild
* @arg {String} guildID The ID of the guild
* @returns {Promise}
*/
leaveGuild(guildID) {
    return this.requestHandler.request(&#x22;DELETE&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">USER_GUILD</span>(&#x22
;@me&#x22;, guildID), true);
}

/**
* Get data on an OAuth2 application
* @arg {String} [appID=&#x22;@me&#x22;] The client ID of the application to get data for. &#x22;@me&#x22; refers to the logged in
 user&#x27;s own application
* @returns {Promise&#x3c;Object&#x3e;} The bot&#x27;s application data. Refer to [the official Discord API documentation entry](
https://discordapp.com/developers/docs/topics/oauth2#get-current-application-information) for object structure
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.USER_GUILDS" id="apidoc.element.eris.Endpoints.USER_GUILDS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_GUILDS
        <span class="apidocSignatureSpan">(userID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(userID) =&#x3e; `/users/${userID}/guilds`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {String} [after] The highest guild ID of the previous page
* @returns {Promise&#x3c;Guild[]&#x3e;}
*/
getRESTGuilds(limit, before, after) {
    if(!this.options.restMode) {
        return Promise.reject(new Error(&#x22;Eris REST mode is not enabled&#x22;));
    }
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">USER_GUILDS</span>(&#x22;@
me&#x22;), true, {
        limit,
        before,
        after
    }).then((guilds) =&#x3e; guilds.map((guild) =&#x3e; new Guild(guild, this)));
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.USER_NOTE" id="apidoc.element.eris.Endpoints.USER_NOTE">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_NOTE
        <span class="apidocSignatureSpan">(userID, targetID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(userID, targetID) =&#x3e; `/users/${userID}/note/${targetID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Edit the current user&#x27;s note for another user (user accounts only)
* @arg {String} note The note
* @returns {Promise}
*/
editUserNote(userID, note) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">USER_NOTE</span>(&#x22;@me
&#x22;, userID), true, {
        note: note
    });
}

/**
* Delete the current user&#x27;s note for another user (user accounts only)
* @returns {Promise}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.USER_PROFILE" id="apidoc.element.eris.Endpoints.USER_PROFILE">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_PROFILE
        <span class="apidocSignatureSpan">(userID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(userID) =&#x3e; `/users/${userID}/profile`</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Get profile data for a user (user accounts only)
* @arg {String} userID The ID of the target user
* @returns {Promise&#x3c;Object&#x3e;} The user&#x27;s profile data.
*/
getUserProfile(userID) {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">USER_PROFILE</span>(userID
), true);
}

/**
* Edit the current user&#x27;s note for another user (user accounts only)
* @arg {String} note The note
* @returns {Promise}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.USER_RELATIONSHIP" id="apidoc.element.eris.Endpoints.USER_RELATIONSHIP">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_RELATIONSHIP
        <span class="apidocSignatureSpan">(userID, relID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(userID, relID) =&#x3e; `/users/${userID}/relationships/${relID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Create a relationship with a user
* @arg {String} userID The ID of the target user
* @arg {Boolean} [block=false] If true, block the user. Otherwise, add the user as a friend
* @returns {Promise}
*/
addRelationship(userID, block) {
    return this.requestHandler.request(&#x22;PUT&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">USER_RELATIONSHIP</span>(&#
x22;@me&#x22;, userID), true, {
        type: block ? 2 : undefined
    });
}

/**
* Remove a relationship with a user
* @arg {String} userID The ID of the target user
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.USER_SETTINGS" id="apidoc.element.eris.Endpoints.USER_SETTINGS">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>USER_SETTINGS
        <span class="apidocSignatureSpan">(userID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(userID) =&#x3e; `/users/${userID}/settings`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
* Get user settings (user accounts only)
* @returns {Promise&#x3c;Object&#x3e;} The user&#x27;s settings data.
*/
getUserSettings() {
    return this.requestHandler.request(&#x22;GET&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">USER_SETTINGS</span>(&#x22
;@me&#x22;), true);
}

/**
* Create a relationship with a user
* @arg {String} userID The ID of the target user
* @arg {Boolean} [block=false] If true, block the user. Otherwise, add the user as a friend
* @returns {Promise}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.WEBHOOK" id="apidoc.element.eris.Endpoints.WEBHOOK">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>WEBHOOK
        <span class="apidocSignatureSpan">(hookID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(hookID) =&#x3e; `/webhooks/${hookID}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Get a webhook
* @arg {String} webhookID The ID of the webhook
* @arg {String} [token] The token of the webhook, used instead of the Bot Authorization token
* @returns {Promise&#x3c;Object&#x3e;} Resolves with a webhook object
*/
getWebhook(webhookID, token) {
    return this.requestHandler.request(&#x22;GET&#x22;, token ? Endpoints.WEBHOOK_TOKEN(webhookID, token) : Endpoints.<span class
="apidocCodeKeywordSpan">WEBHOOK</span>(webhookID), !token);
}

/**
* Create a channel webhook
* @arg {String} channelID The ID of the channel to create the webhook in
* @arg {Object} options Webhook options
* @arg {String} options.name The default name
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.WEBHOOK_TOKEN" id="apidoc.element.eris.Endpoints.WEBHOOK_TOKEN">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>WEBHOOK_TOKEN
        <span class="apidocSignatureSpan">(hookID, token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(hookID, token) =&#x3e; `/webhooks/${hookID}/${token}`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Get a webhook
* @arg {String} webhookID The ID of the webhook
* @arg {String} [token] The token of the webhook, used instead of the Bot Authorization token
* @returns {Promise&#x3c;Object&#x3e;} Resolves with a webhook object
*/
getWebhook(webhookID, token) {
    return this.requestHandler.request(&#x22;GET&#x22;, token ? Endpoints.<span class="apidocCodeKeywordSpan">WEBHOOK_TOKEN</span
>(webhookID, token) : Endpoints.WEBHOOK(webhookID), !token);
}

/**
* Create a channel webhook
* @arg {String} channelID The ID of the channel to create the webhook in
* @arg {Object} options Webhook options
* @arg {String} options.name The default name
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.Endpoints.WEBHOOK_TOKEN_SLACK" id="apidoc.element.eris.Endpoints.WEBHOOK_TOKEN_SLACK">
        function <span class="apidocSignatureSpan">eris.Endpoints.</span>WEBHOOK_TOKEN_SLACK
        <span class="apidocSignatureSpan">(hookID, token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(hookID, token) =&#x3e; `/webhooks/${hookID}/${token}/slack`</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @arg {Object} options Slack webhook options
* @arg {Boolean} [options.wait=false] Whether to wait for the server to confirm the message create or not
* @returns {Promise}
*/
executeSlackWebhook(webhookID, token, options) {
    var wait = !!options.wait;
    options.wait = undefined;
    return this.requestHandler.request(&#x22;POST&#x22;, Endpoints.<span class="apidocCodeKeywordSpan">WEBHOOK_TOKEN_SLACK</span
>(webhookID, token) + (wait ? &#x22;?wait=true&#x22; : &#x22;&#x22;), true, options);
}

/**
* Delete a webhook
* @arg {String} webhookID The ID of the webhook
* @arg {String} [token] The token of the webhook, used instead of the Bot Authorization token
* @returns {Promise}
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eris.FFmpegDuplex" id="apidoc.module.eris.FFmpegDuplex">module eris.FFmpegDuplex</a></h1>


    <h2>
        <a href="#apidoc.element.eris.FFmpegDuplex.FFmpegDuplex" id="apidoc.element.eris.FFmpegDuplex.FFmpegDuplex">
        function <span class="apidocSignatureSpan">eris.</span>FFmpegDuplex
        <span class="apidocSignatureSpan">(command, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class FFmpegDuplex extends DuplexStream {
    constructor(command, options) {
        options = options || {};
        if(options.highWaterMark === undefined) {
            options.highWaterMark = 0;
        }
        super(options);

        this.command = command;
        this._reader = new PassThroughStream(options);
        this._writer = new PassThroughStream(options);

        this._onError = this.emit.bind(this, &#x22;error&#x22;);

        this._reader.on(&#x22;error&#x22;, this._onError);
        this._writer.on(&#x22;error&#x22;, this._onError);

        this._readableState = this._reader._readableState;
        this._writableState = this._writer._writableState;

        [&#x22;on&#x22;, &#x22;once&#x22;, &#x22;removeListener&#x22;, &#x22;removeListeners&#x22;, &#x22;listeners&#x22;].forEach((method) =&#x3e; {
            var og = DuplexStream.prototype[method];

            this[method] = function(ev, fn) {
                var substream = delegateEvents[ev];
                if (substream) {
                    return this[substream][method](ev, fn);
                } else {
                    return og.call(this, ev, fn);
                }
            };
        });
    }

    spawn(args, options) {
        options = options || {};
        var ex, exited, killed, ended;
        var stderr = [];

        var onStdoutEnd = () =&#x3e; {
            if (exited &#x26;&#x26; !ended) {
                ended = true;
                this._reader.end();
                setImmediate(this.emit.bind(this, &#x22;close&#x22;));
            }
        };

        var onStderrData = (chunk) =&#x3e; {
            stderr.push(chunk);
        };

        var onExit = (code, signal) =&#x3e; {
            if(exited) {
                return;
            }
            exited = true;

            if (killed) {
                if (ex) {
                    this.emit(&#x22;error&#x22;, ex);
                }
                this.emit(&#x22;close&#x22;);
            } else if (code === 0 &#x26;&#x26; signal == null) {
                // All is well
                onStdoutEnd();
            } else {
                // Everything else
                ex = new Error(&#x22;Command failed: &#x22; + Buffer.concat(stderr).toString(&#x22;utf8&#x22;));
                ex.killed = this._process.killed || killed;
                ex.code = code;
                ex.signal = signal;
                this.emit(&#x22;error&#x22;, ex);
                this.emit(&#x22;close&#x22;);
            }

            cleanup();
        };

        var onError = (err) =&#x3e; {
            ex = err;
            this._stdout.destroy();
            this._stderr.destroy();
            onExit();
        };

        var kill = () =&#x3e; {
            if(killed) {
                return;
            }
            this._stdout.destroy();
            this._stderr.destroy();

            killed = true;

            try {
                this._process.kill(options.killSignal || &#x22;SIGTERM&#x22;);
                setTimeout(() =&#x3e; this._process &#x26;&#x26; this._process.kill(&#x22;SIGKILL&#x22;), 2000);
            } catch (e) {
                ex = e;
                onExit();
            }
        };

        var cleanup = () =&#x3e; {
            this._process =
            this._stderr =
            this._stdout =
            this._stdin =
            stderr =
            ex =
            killed = null;

            this.kill =
            this.destroy = this.noop;
        };

        this._process = ChildProcess.spawn(this.command, args, options);
        this._stdin = this._process.stdin;
        this._stdout = this._process.stdout;
        this._stderr = this._process.stderr;
        this._writer.pipe(this._stdin);
        this._stdout.pipe(this._reader, {
            end: false
        });
        this.kill = this.destroy = kill;

        // this._stderr.pipe(process.stderr);
        this._stderr.on(&#x22;data&#x22;, onStderrData);

        // In some cases ECONNRESET can be emitted by stdin because the process is not interested in any
        // more data but the _writer is still piping. Forget about errors emitted on stdin and stdout
        this._stdin.on(&#x22;error&#x22;, this.noop);
        this._stdout.on(&#x22;error&#x22;, this.noop);

        this._stdout.on(&#x22;end&#x22;, onStdoutEnd);

        this._process.once(&#x22;close&#x22; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eris.FFmpegDuplex.spawn" id="apidoc.element.eris.FFmpegDuplex.spawn">
        function <span class="apidocSignatureSpan">eris.FFmpegDuplex.</span>spawn
        <span class="apidocSignatureSpan">(connection, args, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spawn = function (connection, args, options) {
    return new FFmpegDuplex(connection, options).spawn(args, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            data.url = data.url.substring(0, data.url.indexOf(&#x22;?&#x22;));
        }
        if(!data.url.endsWith(&#x22;/&#x22;)) {
            data.url += &#x22;/&#x22;;
        }
        this.gatewayURL = data.url + &#x22;?v=&#x22; + Constants.GATEWAY_VERSION + &#x22;&#x26;encoding=&#x22; + (Erlpack ? &#x22
;etf&#x22; : &#x22;json&#x22;);
        for(var i = this.options.firstShardID; i &#x3c;= this.options.lastShardID; ++i) {
            this.shards.<span class="apidocCodeKeywordSpan">spawn</span>(i);
        }
    }).catch((err) =&#x3e; {
        this.emit(&#x22;error&#x22;, err);
        setTimeout(() =&#x3e; this.connect(), 2000);
    });
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eris.FFmpegDuplex.prototype" id="apidoc.module.eris.FFmpegDuplex.prototype">module eris.FFmpegDuplex.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eris.FFmpegDuplex.prototype.addListener" id="apidoc.element.eris.FFmpegDuplex.prototype.addListener">
        function <span class="apidocSignatureSpan">eris.FFmpegDuplex.prototype.</span>addListener
        <span class="apidocSignatureSpan">(ev, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function (ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn);

  if (ev === &#x27;data&#x27;) {
    // Start flowing on next tick if stream isn&#x27;t explicitly paused
    if (this._readableState.flowing !== false)
      this.resume();
  } else if (ev === &#x27;readable&#x27;) {
    const state = this._readableState;
    if (!state.endEmitted &#x26;&#x26; !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
